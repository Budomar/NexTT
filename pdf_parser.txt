        print("   df = parser.parse_with_lazy_loading('file.pdf', start_page=1, end_page=100)")
# pdf_parser.py
import pandas as pd
import traceback
from typing import Optional, List, Dict, Any, Callable
import re
import os
import glob
from datetime import datetime
import json


class PDFParser:
    """
    –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô –í–°–ï–Ø–î–ù–´–ô –ü–ê–†–°–ï–† PDF –° –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –û–¢–õ–ê–î–ö–û–ô –ò –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ï–ô
    –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ—Ç —á—Ç–µ–Ω–∏–µ, –ø–∞—Ä—Å–∏–Ω–≥ –∏ –ø–µ—Ä–µ–ø–æ–¥–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∏–∑ PDF –≤ Excel
    –¢–µ–ø–µ—Ä—å —Å –ø—Ä–æ–ø—É—Å–∫–æ–º –Ω–µ—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
    """
    def __init__(self, progress_callback: Optional[Callable[[int, int], None]] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞
        :param progress_callback: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: callback(current_page, total_pages)
        """
        self.supported_types = {"VK-PROF", "K-PROF"}
        self.debug_mode = True  # –í–ö–õ–Æ–ß–ê–ï–ú –û–¢–õ–ê–î–ö–£ –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ
        self.analysis_results = {}
        self.progress_callback = progress_callback
        
        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü (—Ä–∞–¥–∏–∞—Ç–æ—Ä—ã –∏ —Å–º–µ–∂–Ω–∞—è —Ç–µ–º–∞—Ç–∏–∫–∞)
        self.radiator_keywords = [
            # –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ—Ä–º–∏–Ω—ã
            '—Ä–∞–¥–∏–∞—Ç–æ—Ä', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω—ã–π', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω–∞—è', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω–æ–µ', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω—ã–µ',
            '—Å—Ç–∞–ª—å–Ω–æ–π', '–ø–∞–Ω–µ–ª—å–Ω—ã–π', '–ø–∞–Ω–µ–ª—å–Ω–∞—è', '–ø–∞–Ω–µ–ª—å–Ω–æ–µ', '–ø–∞–Ω–µ–ª—å–Ω—ã–µ',
            '–æ—Ç–æ–ø–ª–µ–Ω–∏–µ', '–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω—ã–π', '–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω–∞—è', '–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω–æ–µ', 
            '–∫–æ–Ω–≤–µ–∫—Ç–æ—Ä', '–∫–æ–Ω–≤–µ–∫—Ç–æ—Ä–Ω—ã–π',
            
            # –¢–∏–ø—ã –∏ —Å–µ—Ä–∏–∏
            '—Ç–∏–ø 11', '—Ç–∏–ø 22', '—Ç–∏–ø 33', '—Ç–∏–ø 21', '—Ç–∏–ø 23', '—Ç–∏–ø 10', '—Ç–∏–ø 20',
            'h33', 'h22', 'h21', 'c21', 'c22', 'h33-', 'h22-', 'h21-', 'c11',
            'compact', 'ventil', '–≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–π', 'hygiene', '—É–Ω–∏–≤–µ—Ä—Å–∞–ª',
            
            # –ë—Ä–µ–Ω–¥—ã
            'royal', 'thermo', 'royal thermo', 'buderus', 'kermi', 'purmo', 'purmo',
            'evra', 'hiterm', 'cv', 'ftv', 'fto', 'ftk',
            
            # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
            '–Ω–∏–∂–Ω–∏–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º', '–±–æ–∫–æ–≤—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º',
            '–Ω–∏–∂–Ω–µ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ', '–±–æ–∫–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ', '–Ω–∏–∂–Ω–∏–π –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ',
            '—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ',
            
            # –†–∞–∑–º–µ—Ä—ã
            '–≤—ã—Å–æ—Ç–æ–π', '–¥–ª–∏–Ω–æ–π', 'l=', '–≤—ã—Å–æ—Ç–∞', '–¥–ª–∏–Ω–∞', '—à–∏—Ä–∏–Ω–∞', '–≥–ª—É–±–∏–Ω–∞',
            '500x800', '300x1000', '400x1200', '600x900',
            
            # –ê–Ω–≥–ª–∏–π—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã
            'radiator', 'panel', 'heater', 'steel', 'radiators', 'convector',
            'panel radiator', 'steel panel',
            
            # –î–ª—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–π
            '—Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è', '–≤–µ–¥–æ–º–æ—Å—Ç—å', '–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ', '–º–∞—Ç–µ—Ä–∏–∞–ª—ã',
            '–ø–æ–∑–∏—Ü–∏—è', '–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ', '–º–∞—Ä–∫–∞', '—Ç–∏–ø',
            
            # –ï–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è
            '—à—Ç', '—à—Ç.', '–µ–¥', '–µ–¥.', 'pcs', 'pc', 'qty', 'quantity',
            '–∫–æ–ª-–≤–æ', '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', '–µ–¥–∏–Ω–∏—Ü',
            
            # –ú–æ—â–Ω–æ—Å—Ç—å
            '–≤—Ç', '–≤–∞—Ç—Ç', 'watt', 'qn', 'qp', '–º–æ—â–Ω–æ—Å—Ç—å', '—Ç–µ–ø–ª–æ–æ—Ç–¥–∞—á–∞',
            
            # –†–µ–≥–∏—Å—Ç—Ä—ã
            '—Ä–≥-', '—Ä–µ–≥–∏—Å—Ç—Ä', '—Ä–µ–≥–∏—Å—Ç—Ä–æ–≤—ã–π',
        ]
    
    def get_pdf_page_count(self, file_path: str) -> int:
        """
        –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ PDF —Ñ–∞–π–ª–µ
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :return: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü
        """
        try:
            import pdfplumber
            with pdfplumber.open(file_path) as pdf:
                return len(pdf.pages)
        except Exception as e:
            self._log(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç—Ä–∞–Ω–∏—Ü: {e}", "ERROR")
            raise RuntimeError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ PDF: {e}")
    def _log(self, message: str, level: str = "INFO"):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ –∫–æ–Ω—Å–æ–ª—å"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        log_message = f"[{timestamp}][{level}] {message}"
        print(log_message)

    def _log_table_info(self, table: List, table_name: str):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–∞–±–ª–∏—Ü–µ"""
        if not table:
            self._log(f"üì≠ –¢–∞–±–ª–∏—Ü–∞ {table_name}: –ü–£–°–¢–ê–Ø", "DEBUG")
            return
        rows_count = len(table)
        cols_count = max(len(row) for row in table) if table else 0
        non_empty_cells = sum(1 for row in table for cell in row if cell and str(cell).strip())
        self._log(f"üìä –¢–∞–±–ª–∏—Ü–∞ {table_name}: {rows_count} —Å—Ç—Ä–æ–∫, {cols_count} –∫–æ–ª–æ–Ω–æ–∫, {non_empty_cells} –Ω–µ–ø—É—Å—Ç—ã—Ö —è—á–µ–µ–∫", "DEBUG")
        for i, row in enumerate(table[:2]):
            row_preview = [str(cell)[:50] + "..." if cell and len(str(cell)) > 50 else str(cell) for cell in row[:5]]
            self._log(f"   –°—Ç—Ä–æ–∫–∞ {i}: {row_preview}", "DEBUG")

    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–¢–†–ê–ù–ò–¶–´ ============
    def _should_process_page(self, page, page_num: int) -> bool:
        """
        –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, —Å—Ç–æ–∏—Ç –ª–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True –µ—Å–ª–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –µ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–∏ —Ç–∞–±–ª–∏—Ü —Å —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞–º–∏
        """
        try:
            # 1. –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            text = page.extract_text()
            
            # 2. –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–π (< 50 —Å–∏–º–≤–æ–ª–æ–≤) - –≤–µ—Ä–æ—è—Ç–Ω–æ, —ç—Ç–æ —á–µ—Ä—Ç–µ–∂/—Å—Ö–µ–º–∞
            if not text or len(text.strip()) < 50:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –ü–†–û–ü–£–°–ö (–º–∞–ª–æ —Ç–µ–∫—Å—Ç–∞, –≤–µ—Ä–æ—è—Ç–Ω–æ —á–µ—Ä—Ç–µ–∂)", "SKIP")
                return False
            
            text_lower = text.lower()
            
            # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ (–†–ê–°–®–ò–†–ï–ù–ù–´–ô –°–ü–ò–°–û–ö)
            found_keywords = []
            for keyword in self.radiator_keywords:
                if keyword in text_lower:
                    found_keywords.append(keyword)
            
            # 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤ (–†–ê–°–®–ò–†–ï–ù–ù–´–ï)
            radiator_patterns = [
                r'\b[H–°C–öK]\d{1,2}[-\s]*\d{3,4}[-\s]*\d{3,4}\b',  # H33-200-1000, C21-300-600
                r'\bPURMO\s+[CHK]\s*\d{1,2}',  # PURMO C 21, PURMO H 20
                r'\b—Ç–∏–ø\s*\d+\s*[Ll]\s*[=:]\s*\d+\s*–º–º',
                r'\b–≤—ã—Å–æ—Ç–æ–π\s*\d+\s*–º–º',
                r'\b–¥–ª–∏–Ω[–∞–æ–π]\s*\d+\s*–º–º',
                r'\b\d{3,4}\s*[x—Ö√ó]\s*\d{3,4}\s*–í—Ç\b',  # 500x800 –í—Ç
                r'\b[Qq][–Ωp]\s*[=:]\s*\d+\s*–í—Ç\b',  # Q–Ω=2356 –í—Ç
                r'\b(?:—Ä–∞–¥–∏–∞—Ç–æ—Ä|–∫–æ–Ω–≤–µ–∫—Ç–æ—Ä)\s*[^.]{0,50}\d+\s*—à—Ç\b',  # —Ä–∞–¥–∏–∞—Ç–æ—Ä ... 2 —à—Ç
            ]
            
            found_patterns = []
            for pattern in radiator_patterns:
                if re.search(pattern, text_lower, re.IGNORECASE):
                    found_patterns.append(pattern)
            
            # 5. –ò—â–µ–º —Å—Ç–æ–ª–±–µ—Ü "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ" –∏–ª–∏ "–ö–æ–ª-–≤–æ" (—Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã)
            has_quantity_column = re.search(
                r'–∫–æ–ª–∏[ -]?—á–µ—Å—Ç–≤–æ|–∫–æ–ª[ -]?–≤–æ|–µ–¥\.|—à—Ç\.|pcs|pc|qty|–µ–¥–∏–Ω–∏—Ü|—à—Ç—É–∫',
                text_lower
            )
            
            # 6. –ò—â–µ–º —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏/–≤–µ–¥–æ–º–æ—Å—Ç–∏
            has_spec_header = re.search(
                r'—Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è|–≤–µ–¥–æ–º–æ—Å—Ç—å|–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω[–∏–µ—è]|–º–∞—Ç–µ—Ä–∏–∞–ª[—ã–æ–≤]|–ø–æ–∑–∏—Ü–∏—è|–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ',
                text_lower
            )
            
            # 7. –õ–æ–≥–∏—Ä—É–µ–º —á—Ç–æ –Ω–∞—à–ª–∏
            if found_keywords:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –Ω–∞–π–¥–µ–Ω—ã –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: {found_keywords[:3]}...", "CHECK")
            if found_patterns:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –Ω–∞–π–¥–µ–Ω—ã –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤", "CHECK")
            if has_quantity_column:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –µ—Å—Ç—å —Å—Ç–æ–ª–±–µ—Ü –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞", "CHECK")
            if has_spec_header:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –µ—Å—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏", "CHECK")
            
            # 8. –ö—Ä–∏—Ç–µ—Ä–∏–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–ë–û–õ–ï–ï –ì–ò–ë–ö–ò–ï):
            # - –ï—Å—Ç—å –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –ò–õ–ò –ø–∞—Ç—Ç–µ—Ä–Ω—ã
            # - –ò (—Å—Ç–æ–ª–±–µ—Ü –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ò–õ–ò –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏)
            should_process = (
                (len(found_keywords) >= 1 or len(found_patterns) >= 1) and 
                (has_quantity_column or has_spec_header)
            )
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫—Ä–∏—Ç–µ—Ä–∏–π: –µ—Å–ª–∏ –µ—Å—Ç—å —á–µ—Ç–∫–∏–µ –º–æ–¥–µ–ª–∏ PURMO, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
            if not should_process and re.search(r'PURMO\s+[CHK]\s*\d{1,2}', text_lower):
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –Ω–∞–π–¥–µ–Ω—ã –º–æ–¥–µ–ª–∏ PURMO, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º", "CHECK")
                should_process = True
            
            if not should_process:
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}: –ü–†–û–ü–£–°–ö (–Ω–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ç–∞–±–ª–∏—Ü —Å —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞–º–∏)", "SKIP")
                # –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ –ø–µ—Ä–≤—ã—Ö —Å—Ç—Ä–æ–∫ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                lines = text.split('\n')[:5]
                preview = ' | '.join([line[:50] for line in lines if line.strip()])
                if preview:
                    self._log(f"   üìù –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä: {preview[:100]}...", "DEBUG")
            
            return should_process
            
        except Exception as e:
            self._log(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page_num}: {e}", "DEBUG")
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ª—É—á—à–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É (–±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–µ–∂–∏–º)
            return True

    # ============ –î–û–ü–û–õ–ù–ï–ù–ò–Ø –î–õ–Ø –†–ê–î–ò–ê–¢–û–†–û–í ============
    def _normalize_text(self, text: str) -> str:
        """
        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –±–æ—Ä—å–±—ã —Å OCR –∏ —à—É–º–æ–º:
        - –£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –±—É–∫–≤ (aa ‚Üí a)
        - –ó–∞–º–µ–Ω—è–µ—Ç –ª–∞—Ç–∏–Ω–∏—Ü—É –Ω–∞ –∫–∏—Ä–∏–ª–ª–∏—Ü—É
        - –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç x/√ó/—Ö ‚Üí x
        - –£–±–∏—Ä–∞–µ—Ç –∞—Ä—Ç–∏–∫—É–ª—ã –∏ –º—É—Å–æ—Ä
        """
        if not text or not isinstance(text, str):
            return ""
        
        # 1. –£–¥–∞–ª—è–µ–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –±—É–∫–≤—ã (OCR-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã)
        text = re.sub(r'([–∞-—è–ê-–Øa-zA-Z])\1+', r'\1', text)
        
        # 2. –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ª–∞—Ç–∏–Ω–∏—Ü—É –≤ –∫–∏—Ä–∏–ª–ª–∏—Ü—É (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫)
        latin_to_cyrillic = {
            'o': '–æ', 'O': '–û',
            'p': '—Ä', 'P': '–†',
            'a': '–∞', 'A': '–ê',
            'e': '–µ', 'E': '–ï',
            'x': '—Ö', 'X': '–•',
            'c': '—Å', 'C': '–°',
            'y': '—É', 'Y': '–£',
            'k': '–∫', 'K': '–ö',
            'm': '–º', 'M': '–ú',
            't': '—Ç', 'T': '–¢',
            'b': '–≤', 'B': '–í',
            'H': '–ù', 'N': '–ù',
            'f': '—Ñ', 'F': '–§',
            'i': '–∏', 'I': '–ò',
            'g': '–≥', 'G': '–ì',
            'l': '–ª', 'L': '–õ',
            'z': '–∑', 'Z': '–ó',
            'u': '—É', 'j': '–π', 'q': '—è', 'Q': '–Ø',
            'd': '–¥', 'D': '–î',
            'r': '—Ä', 'R': '–†',
            's': '—Å', 'S': '–°',
            'v': '–≤', 'V': '–í',
            'w': '—à', 'W': '–®',
            'h': '–Ω', 'H': '–ù',
            'n': '–ø', 'N': '–ü',
        }
        
        for en, ru in latin_to_cyrillic.items():
            text = text.replace(en, ru)
        
        # 3. –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã "x" –∫ –µ–¥–∏–Ω–æ–º—É –≤–∏–¥—É
        text = re.sub(r'[x√ó—Ö]', 'x', text)
        
        # 4. –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—ã–µ –≤ —á–∏—Å–ª–∞—Ö –Ω–∞ —Ç–æ—á–∫–∏ (1,5 ‚Üí 1.5)
        text = re.sub(r'(\d),(\d)', r'\1.\2', text)
        
        # 5. –£–±–∏—Ä–∞–µ–º –∞—Ä—Ç–∏–∫—É–ª—ã –∏ –º—É—Å–æ—Ä
        text = re.sub(r'(?:–∞—Ä—Ç|–∞—Ä—Ç–∏–∫—É–ª|code|–∫–æ–¥)\s*[.:]?\s*\S*\d+\S*', '', text, flags=re.IGNORECASE)
        
        # 6. –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –¥–µ—Ñ–∏—Å—ã
        text = re.sub(r'\s+', ' ', text)
        text = re.sub(r'[-\s]+', '-', text)
        
        # 7. –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ —Å–∏–º–≤–æ–ª—ã –≤ –Ω–∞—á–∞–ª–µ/–∫–æ–Ω—Ü–µ
        text = text.strip('.,;:!?()[]{}"\'')
        
        return text.strip()

    def extract_radiator_name(self, text: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞ —Å —É—á—ë—Ç–æ–º —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤"""
        if not text or not isinstance(text, str):
            return None
        
        clean_text = self._normalize_text(text)
        
        # –†–ê–°–®–ò–†–ï–ù–ù–´–ï –ü–ê–¢–¢–ï–†–ù–´ –î–õ–Ø –í–°–ï–Ø–î–ù–û–°–¢–ò
        patterns = [
            # 1. PURMO —Ñ–æ—Ä–º–∞—Ç: PURMO C 21s 500x800
            r'\bPURMO\s+([CHK])\s*(\d{1,2})s?\s*(\d{2,4})\s*[x—Ö√ó-]\s*(\d{2,4})\b',
            
            # 2. –ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: C21-500-800, H20-400-1200
            r'\b([CHK])\s*(\d{1,2})[-\s]*(\d{2,4})[-\s]*(\d{2,4})\b',
            
            # 3. –° –±—É–∫–≤–æ–π "s": C21s 500x800
            r'\b([CHK])\s*(\d{1,2})s\s*(\d{2,4})\s*[x—Ö√ó]\s*(\d{2,4})\b',
            
            # 4. –ë–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤: C21500800
            r'\b([CHK])\s*(\d{1,2})\s*(\d{2,4})\s*(\d{2,4})\b',
            
            # 5. –° —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏: C21/500/800
            r'\b([CHK])\s*(\d{1,2})[/\\]\s*(\d{2,4})[/\\]\s*(\d{2,4})\b',
            
            # 6. –†–µ–≥–∏—Å—Ç—Ä—ã: –†–ì-113-84-1,5
            r'\b–†–ì[-\s]*(\d{1,3})[-\s]*(\d{1,3})[-\s]*(\d+[.,]?\d*)\b',
            
            # 7. –î—Ä—É–≥–∏–µ –±—Ä–µ–Ω–¥—ã: KERMI FTV 22 600x1000
            r'\b(KERMI|BUDERUS|ROYAL|THERMO)\s+([A-Z]+)?\s*(\d{1,2})\s*(\d{2,4})\s*[x—Ö√ó]\s*(\d{2,4})\b',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, clean_text, re.IGNORECASE)
            if match:
                groups = match.groups()
                
                # –î–ª—è PURMO —Ñ–æ—Ä–º–∞—Ç–∞
                if 'PURMO' in pattern and len(groups) >= 4:
                    return f"PURMO {groups[0]}{groups[1]} {groups[2]}x{groups[3]}"
                
                # –î–ª—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ (C21-500-800)
                elif len(groups) == 4 and groups[0] in ['C', 'H', 'K']:
                    return f"{groups[0]}{groups[1]}-{groups[2]}-{groups[3]}"
                
                # –î–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
                elif '–†–ì' in pattern and len(groups) >= 3:
                    return f"–†–ì-{groups[0]}-{groups[1]}-{groups[2]}"
                
                # –î–ª—è –¥—Ä—É–≥–∏—Ö –±—Ä–µ–Ω–¥–æ–≤
                elif len(groups) >= 5:
                    brand = groups[0]
                    model = f"{groups[2]}" if groups[1] else ""
                    return f"{brand} {model} {groups[3]}x{groups[4]}".strip()
        
        return None

    def extract_quantity_from_row(self, row: pd.Series) -> int:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑ –≤—Å–µ–π —Å—Ç—Ä–æ–∫–∏ DataFrame (–±–æ–ª–µ–µ –≤—Å–µ—è–¥–Ω–æ)"""
        quantity = 0
        
        for cell in row:
            if pd.notna(cell):
                str_cell = str(cell).strip()
                
                # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º
                str_cell = re.sub(r'\s+', ' ', str_cell)
                
                # 1. –ü—Ä—è–º–æ–µ —á–∏—Å–ª–æ (123)
                if re.match(r'^\d+$', str_cell):
                    return int(str_cell)
                
                # 2. –ß–∏—Å–ª–æ —Å –µ–¥–∏–Ω–∏—Ü–∞–º–∏ –∏–∑–º–µ—Ä–µ–Ω–∏—è (2 —à—Ç, 4–µ–¥., 10 —à—Ç.)
                qty_patterns = [
                    r'^(\d+)\s*—à—Ç\.?$',          # "2 —à—Ç", "4—à—Ç."
                    r'^(\d+)\s*–µ–¥\.?$',          # "2 –µ–¥", "4–µ–¥."
                    r'^(\d+)\s*pcs?\.?$',        # "2 pcs", "4pc"
                    r'^qty\s*[=:\s]*(\d+)',      # "qty=2", "qty: 4"
                    r'^–∫–æ–ª-?–≤–æ\s*[=:\s]*(\d+)',  # "–∫–æ–ª-–≤–æ=2", "–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 4"
                    r'^(\d+)\s*$',               # –ü—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ —Å –ø—Ä–æ–±–µ–ª–∞–º–∏ –≤–æ–∫—Ä—É–≥
                ]
                
                for pattern in qty_patterns:
                    match = re.search(pattern, str_cell, re.IGNORECASE)
                    if match:
                        try:
                            return int(match.group(1))
                        except:
                            continue
                
                # 3. –ò—â–µ–º —á–∏—Å–ª–æ –≤ —Å–æ—Å—Ç–∞–≤–µ —Å—Ç—Ä–æ–∫–∏ (–µ—Å–ª–∏ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤)
                # –ù–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –∫–æ—Ä–æ—Ç–∫–∞—è –∏ —è–≤–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                if len(str_cell) < 30:
                    numbers = re.findall(r'\b(\d+)\b', str_cell)
                    if numbers:
                        # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ (—á–∞—Å—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –∫–æ–Ω—Ü–µ)
                        return int(numbers[-1])
        
        return quantity

    def extract_radiators_from_dataframe(self, df: pd.DataFrame) -> List[Dict[str, Any]]:
        """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç DataFrame –≤ —Å–ø–∏—Å–æ–∫ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤"""
        results = []
        for idx, row in df.iterrows():
            full_row_text = ' '.join(str(cell) for cell in row if pd.notna(cell) and str(cell).strip())
            if not full_row_text.strip():
                continue

            context_ok = any(kw in full_row_text.lower() for kw in [
                '—Ä–∞–¥–∏–∞—Ç–æ—Ä', '–ø–∞–Ω–µ–ª—å–Ω—ã–π', 'buderus', 'royal', 'thermo', 'evra', 'k-prof', 'vk-prof', 'cv', 'hiterm',
                'pupmo', '—Å—Ç–∞–ª—å–Ω–æ–π', '–æ—Ç–æ–ø–ª–µ–Ω–∏–µ', '—Ç–∏–ø 11', '—Ç–∏–ø 22', '—Ç–∏–ø 33',
                'compact', 'ventil', '–Ω–∏–∂–Ω–∏–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º', '–±–æ–∫–æ–≤—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º'
            ])
            if not context_ok:
                continue

            radiator_name = self.extract_radiator_name(full_row_text)
            if not radiator_name:
                continue

            quantity = self.extract_quantity_from_row(row)
            if quantity == 0:
                continue

            source_page = row.get('_source_page', 'unknown')
            results.append({
                'name': radiator_name,
                'quantity': quantity,
                'source_page': source_page,
                'original_row': full_row_text[:200]
            })

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥—É–±–ª–∏ –ø–æ (name, source_page)
        unique_results = {}
        for item in results:
            key = (item['name'], item['source_page'])
            if key in unique_results:
                unique_results[key]['quantity'] += item['quantity']
            else:
                unique_results[key] = item

        return list(unique_results.values())

    # ============ –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î –ü–ê–†–°–ò–ù–ì–ê (–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô) –° –ü–û–î–î–ï–†–ñ–ö–û–ô –í–´–ë–û–†–ê –°–¢–†–ê–ù–ò–¶ ============
    def parse_to_dataframe(self, file_path: str, 
                        start_page: int = 1, 
                        end_page: Optional[int] = None,
                        max_pages: Optional[int] = None,
                        pages: Optional[List[int]] = None) -> pd.DataFrame:
        """
        –ì–õ–ê–í–ù–´–ô –ú–ï–¢–û–î - –ø–∞—Ä—Å–∏—Ç –õ–Æ–ë–û–ô PDF –≤ DataFrame —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
        –ü—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã –±–µ–∑ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ç–∞–±–ª–∏—Ü —Å —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞–º–∏
        –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—ã–±–æ—Ä –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü —á–µ—Ä–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä pages
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param start_page: –ù–æ–º–µ—Ä –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å 1) - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ—Å–ª–∏ pages=None
        :param end_page: –ù–æ–º–µ—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (None = –¥–æ –∫–æ–Ω—Ü–∞) - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ—Å–ª–∏ pages=None
        :param max_pages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ—Å–ª–∏ pages=None
        :param pages: –°–ø–∏—Å–æ–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–æ–º–µ—Ä–∞ —Å 1). –ï—Å–ª–∏ –∑–∞–¥–∞–Ω, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç start_page/end_page/max_pages
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        try:
            import pdfplumber
        except ImportError:
            raise RuntimeError("‚ùå –ë–ò–ë–õ–ò–û–¢–ï–ö–ê PDFPLUMBER –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ê! –í—ã–ø–æ–ª–Ω–∏—Ç–µ: pip install pdfplumber")
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"‚ùå –§–ê–ô–õ –ù–ï –ù–ê–ô–î–ï–ù: {file_path}")
        
        self._log("üöÄ" * 50)
        self._log(f"üöÄ –ó–ê–ü–£–°–ö –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û –ü–ê–†–°–ò–ù–ì–ê PDF: {os.path.basename(file_path)}")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã
        if pages is not None:
            self._log(f"üìÑ –†–ï–ñ–ò–ú: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü")
            self._log(f"üìÑ –í—ã–±—Ä–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {sorted(pages)}")
        else:
            self._log(f"üìÑ –†–ï–ñ–ò–ú: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü")
            if start_page != 1:
                self._log(f"üìÑ –ù–ê–ß–ê–õ–¨–ù–ê–Ø –°–¢–†–ê–ù–ò–¶–ê: {start_page}")
            if end_page:
                self._log(f"üìÑ –ö–û–ù–ï–ß–ù–ê–Ø –°–¢–†–ê–ù–ò–¶–ê: {end_page}")
            if max_pages:
                self._log(f"‚ö° –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï: –Ω–µ –±–æ–ª–µ–µ {max_pages} —Å—Ç—Ä–∞–Ω–∏—Ü")
        
        self._log(f"üìÅ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å: {file_path}")
        self._log(f"üìè –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {os.path.getsize(file_path) / 1024 / 1024:.2f} MB")
        self._log("üöÄ" * 50)
        
        try:
            all_tables = []
            total_pages_processed = 0
            total_pages_skipped = 0
            
            with pdfplumber.open(file_path) as pdf:
                total_pages_in_pdf = len(pdf.pages)
                self._log(f"üìÑ –û–ë–ù–ê–†–£–ñ–ï–ù–û –°–¢–†–ê–ù–ò–¶ –í PDF: {total_pages_in_pdf}")
                
                # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
                pages_to_process = []
                
                if pages is not None:
                    # –†–µ–∂–∏–º: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–∞–Ω–∏—Ü
                    valid_pages = []
                    for page_num in pages:
                        if 1 <= page_num <= total_pages_in_pdf:
                            valid_pages.append(page_num)
                        else:
                            self._log(f"‚ö†Ô∏è  –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num} –ø—Ä–æ–ø—É—â–µ–Ω–∞ (–≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ 1-{total_pages_in_pdf})", "WARNING")
                    
                    if not valid_pages:
                        raise ValueError(f"–ù–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏. –î–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü: 1-{total_pages_in_pdf}")
                    
                    pages_to_process = sorted(set(valid_pages))  # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
                    self._log(f"üìÑ –ë—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {len(pages_to_process)} –∏–∑ {len(pages)} –∑–∞–ø—Ä–æ—à–µ–Ω–Ω—ã—Ö")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏
                    start_page = min(pages_to_process)
                    end_page = max(pages_to_process)
                    
                else:
                    # –†–µ–∂–∏–º: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü (—Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞)
                    if start_page < 1:
                        start_page = 1
                        self._log(f"‚ö†Ô∏è  start_page –∏—Å–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ 1 (–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)")
                    
                    if end_page is None:
                        end_page = total_pages_in_pdf
                        self._log(f"üìÑ –ö–æ–Ω–µ—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞, –±–µ—Ä—ë–º –¥–æ –∫–æ–Ω—Ü–∞: {end_page}")
                    elif end_page > total_pages_in_pdf:
                        end_page = total_pages_in_pdf
                        self._log(f"‚ö†Ô∏è  end_page –∏—Å–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ {total_pages_in_pdf} (–º–∞–∫—Å–∏–º—É–º –≤ —Ñ–∞–π–ª–µ)")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                    if start_page > end_page:
                        self._log(f"‚ùå –û–®–ò–ë–ö–ê: start_page ({start_page}) > end_page ({end_page})")
                        raise ValueError(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü: {start_page}-{end_page}")
                    
                    # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ max_pages
                    pages_in_range = end_page - start_page + 1
                    if max_pages and max_pages > 0 and pages_in_range > max_pages:
                        original_end = end_page
                        end_page = start_page + max_pages - 1
                        if end_page > total_pages_in_pdf:
                            end_page = total_pages_in_pdf
                        self._log(f"‚ö° –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï max_pages: —Å–æ–∫—Ä–∞—â–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω —Å {start_page}-{original_end} –¥–æ {start_page}-{end_page}")
                    
                    # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ
                    pages_to_process = list(range(start_page, end_page + 1))
                
                self._log(f"üìÑ –§–ò–ù–ê–õ–¨–ù–´–ô –°–ü–ò–°–û–ö –°–¢–†–ê–ù–ò–¶ –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò: {pages_to_process[:10]}{'...' if len(pages_to_process) > 10 else ''}")
                self._log(f"üìÑ –í–°–ï–ì–û –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò: {len(pages_to_process)} —Å—Ç—Ä.")
                
                # –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
                analysis_pages = min(3, len(pages_to_process))
                for i in range(analysis_pages):
                    page_idx = pages_to_process[i] - 1
                    if page_idx < len(pdf.pages):
                        page = pdf.pages[page_idx]
                        text_preview = page.extract_text()[:100] if page.extract_text() else "–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞"
                        self._log(f"üîç –ü—Ä–µ–≤—å—é —Å—Ç—Ä. {pages_to_process[i]}: {text_preview}...")
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                for idx, page_num in enumerate(pages_to_process):
                    page_idx = page_num - 1
                    page = pdf.pages[page_idx]
                    
                    # üî• –í–´–ó–´–í–ê–ï–ú –û–ë–†–ê–¢–ù–´–ô –í–´–ó–û–í –ü–†–û–ì–†–ï–°–°–ê (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
                    if self.progress_callback:
                        # –ü—Ä–æ–≥—Ä–µ—Å—Å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
                        current_in_range = idx + 1
                        total_in_range = len(pages_to_process)
                        self.progress_callback(current_in_range, total_in_range)
                    
                    # üî• –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê: –°–¢–û–ò–¢ –õ–ò –û–ë–†–ê–ë–ê–¢–´–í–ê–¢–¨ –≠–¢–£ –°–¢–†–ê–ù–ò–¶–£?
                    if not self._should_process_page(page, page_num):
                        total_pages_skipped += 1
                        continue
                    
                    self._log(f"\nüìñ {'='*60}")
                    self._log(f"üìñ –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–†–ê–ù–ò–¶–´ {page_num} (–≤ PDF: —Å—Ç—Ä. {page_num}/{total_pages_in_pdf})")
                    self._log(f"üìñ –ü—Ä–æ–≥—Ä–µ—Å—Å: {idx + 1}/{len(pages_to_process)}")
                    self._log(f"üìñ {'='*60}")
                    
                    page_tables = self._extract_tables_universal(page, page_num)
                    if page_tables:
                        all_tables.extend(page_tables)
                        total_pages_processed += 1
                    
                    # –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü—ã
                    if page_tables:
                        self._extract_and_analyze_text(page, page_num)
            
            # –°–≤–æ–¥–∫–∞ –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ
            self._log(f"\nüìä {'='*60}")
            self._log(f"üìä –°–í–û–î–ö–ê –ü–û –ü–ê–†–°–ò–ù–ì–£:")
            self._log(f"üìä –í—Å–µ–≥–æ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ PDF: {total_pages_in_pdf}")
            
            if pages is not None:
                self._log(f"üìä –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {len(pages)} —à—Ç.")
                self._log(f"üìä –í–∞–ª–∏–¥–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {len(pages_to_process)} —à—Ç.")
            else:
                self._log(f"üìä –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω: {start_page}-{end_page}")
            
            self._log(f"üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_processed}")
            self._log(f"üìä –ü—Ä–æ–ø—É—â–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_skipped}")
            self._log(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(all_tables)}")
            
            if pages_to_process and (min(pages_to_process) > 1 or max(pages_to_process) < total_pages_in_pdf):
                self._log(f"üìä –ü–∞—Ä—Å–∏–Ω–≥ –≤—ã–ø–æ–ª–Ω–µ–Ω –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(pages_to_process)} –∏–∑ {total_pages_in_pdf} —Å—Ç—Ä–∞–Ω–∏—Ü")
            
            if max_pages and len(pages_to_process) >= max_pages:
                self._log(f"üìä –î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ max_pages: {max_pages}")
                
            self._log(f"üìä –≠–∫–æ–Ω–æ–º–∏—è –≤—Ä–µ–º–µ–Ω–∏: {(total_pages_skipped/len(pages_to_process))*100:.1f}% —Å—Ç—Ä–∞–Ω–∏—Ü –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            self._log(f"üìä {'='*60}")
            
            if all_tables:
                # –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –ª—É—á—à–∏–µ —Ç–∞–±–ª–∏—Ü—ã (–±–µ–∑ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü)
                best_tables = []
                pages_processed = set()
                for table in all_tables:
                    page = table['_source_page'].iloc[0] if '_source_page' in table.columns else 0
                    if page not in pages_processed:
                        best_tables.append(table)
                        pages_processed.add(page)
                
                self._log(f"üìä –í—ã–±—Ä–∞–Ω–æ {len(best_tables)} –ª—É—á—à–∏—Ö —Ç–∞–±–ª–∏—Ü –∏–∑ {len(all_tables)}")
                result_df = self._merge_all_tables(best_tables)
            else:
                result_df = pd.DataFrame()
            
            result_df = self._replace_na_values(result_df)
            self._analyze_final_result(result_df, file_path)
            
            if not result_df.empty:
                self._log(f"‚úÖ –£–°–ü–ï–•! –°–û–ó–î–ê–ù DATAFRAME: {result_df.shape}")
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–∞–¥–∏–∞—Ç–æ—Ä—ã –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                radiators = self.extract_radiators_from_dataframe(result_df)
                self._log(f"‚úÖ –ò–∑–≤–ª–µ—á–µ–Ω–æ {len(radiators)} –ø–æ–∑–∏—Ü–∏–π —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤")
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä—ã –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤
                if radiators:
                    self._log("üìã –ü—Ä–∏–º–µ—Ä—ã –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤:")
                    for i, rad in enumerate(radiators[:5]):
                        self._log(f"   {i+1}. {rad['name']} - {rad['quantity']} —à—Ç. (—Å—Ç—Ä. {rad['source_page']})")
            else:
                self._log("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –í PDF –ù–ï –ù–ê–ô–î–ï–ù–û –¢–ê–ë–õ–ò–ß–ù–´–• –î–ê–ù–ù–´–•")
            
            return result_df
            
        except Exception as e:
            error_msg = f"‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –ü–ê–†–°–ò–ù–ì–ê {file_path}:\n{str(e)}\n{traceback.format_exc()}"
            self._log(error_msg, "ERROR")
            raise RuntimeError(error_msg)

    # ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ============
    def parse_to_dataframe_with_pages(self, file_path: str, pages: List[int]) -> pd.DataFrame:
        """
        –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param pages: –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–æ–º–µ—Ä–∞ —Å 1)
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        return self.parse_to_dataframe(file_path, pages=pages)
    
    def _analyze_pdf_structure_quick(self, pdf, max_pages: int = 3):
        """–ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã PDF (—Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã)"""
        self._log(f"\nüîç –ë–´–°–¢–†–´–ô –ê–ù–ê–õ–ò–ó –°–¢–†–£–ö–¢–£–†–´ PDF (–ø–µ—Ä–≤—ã–µ {max_pages} —Å—Ç—Ä–∞–Ω–∏—Ü):")
        try:
            metadata = pdf.metadata
            if metadata:
                self._log(f"üìã –¢–∏–ø PDF: {metadata.get('Producer', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
            
            for i in range(min(max_pages, len(pdf.pages))):
                page = pdf.pages[i]
                text = page.extract_text()[:200] if page.extract_text() else "–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞"
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {i+1}: {page.width:.1f}x{page.height:.1f}, —Ç–µ–∫—Å—Ç: {text[:100]}...")
                
        except Exception as e:
            self._log(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ PDF: {e}", "DEBUG")

    # ============ –°–¢–ê–ù–î–ê–†–¢–ù–´–ï –ú–ï–¢–û–î–´ (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) ============
    def _analyze_pdf_structure(self, pdf):
        self._log("\nüîç –ê–ù–ê–õ–ò–ó –°–¢–†–£–ö–¢–£–†–´ PDF:")
        try:
            metadata = pdf.metadata
            if metadata:
                self._log(f"üìã –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ PDF: {json.dumps(metadata, indent=2, default=str)}")
            for i in range(min(3, len(pdf.pages))):
                page = pdf.pages[i]
                self._log(f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {i+1}: {page.width:.1f}x{page.height:.1f}, —Å–ª–æ–≤: {len(page.extract_words())}")
        except Exception as e:
            self._log(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã PDF: {e}", "DEBUG")

    def _extract_tables_universal(self, page, page_num: int) -> List[pd.DataFrame]:
        tables_df = []
        strategies = [
            {"name": "–°–¢–†–ê–¢–ï–ì–ò–Ø –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ", "params": {}},
            {"name": "–õ–ò–ù–ò–ò+–õ–ò–ù–ò–ò", "params": {"vertical_strategy": "lines", "horizontal_strategy": "lines"}},
            {"name": "–¢–ï–ö–°–¢+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "text", "horizontal_strategy": "text"}},
            {"name": "–õ–ò–ù–ò–ò+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "lines", "horizontal_strategy": "text"}},
            {"name": "–¢–ï–ö–°–¢+–õ–ò–ù–ò–ò", "params": {"vertical_strategy": "text", "horizontal_strategy": "lines"}},
            {"name": "–°–ù–ò–ü–ü–ï–¢–´", "params": {"snap_tolerance": 5, "join_tolerance": 5}},
        ]
        for strategy in strategies:
            strategy_name = strategy["name"]
            strategy_params = strategy["params"]
            self._log(f"\nüéØ –ò–°–ü–û–õ–¨–ó–£–Æ –°–¢–†–ê–¢–ï–ì–ò–Æ: {strategy_name}")
            self._log(f"‚öôÔ∏è  –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: {strategy_params}")
            try:
                tables = page.extract_tables(strategy_params)
                if tables:
                    self._log(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(tables)}")
                    for table_idx, table in enumerate(tables):
                        table_name = f"–°—Ç—Ä–∞–Ω–∏—Ü–∞_{page_num}_{strategy_name}_–¢–∞–±–ª–∏—Ü–∞_{table_idx+1}"
                        self._log_table_info(table, table_name)
                        if table and self._is_valid_table(table):
                            df = self._table_to_dataframe(table, page_num, strategy_name, table_idx)
                            if not df.empty:
                                # === –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –ú–£–°–û–†–ù–´–• –¢–ê–ë–õ–ò–¶ ===
                                if df.shape[0] < 2 or df.shape[1] < 2:
                                    self._log(f"‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞: —Å–ª–∏—à–∫–æ–º –º–µ–ª–∫–∞—è ({df.shape})", "DEBUG")
                                    continue
                                text_flat = ' '.join(df.astype(str).values.flatten())
                                radiator_keywords = (
                                    r'—Ä–∞–¥–∏–∞—Ç–æ—Ä|—Å—Ç–∞–ª—å–Ω–æ–π|–ø–∞–Ω–µ–ª—å–Ω—ã–π|–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω|'
                                    r'radiator|heater|panel\s+heater|convector|'
                                    r'—à—Ç|—à—Ç\.|–µ–¥|–µ–¥\.|pcs|pc|pieces|qty|quantity|q-?ty|–∫–æ–ª-?–≤–æ|–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ|'
                                    r'U\d{2}-\d{3,4}-\d{3,4}|C\d{2}-\d{3,4}-\d{3,4}|'
                                    r'[VK]\d{2}|VK-\d{2}|K-\d{2}|type\s*\d+|—Ç–∏–ø\s*\d+|'
                                    r'compact|classic|ventil|prado|purmo|kermi|royal|ftv|fto|ftk|'
                                    r'–Ω–∏–∂–Ω(?:–µ–µ|–∏–π)\s+–ø–æ–¥–∫–ª—é—á|–±–æ–∫–æ–≤\w+\s+–ø–æ–¥–∫–ª—é—á|universal'
                                )
                                if not re.search(radiator_keywords, text_flat, re.IGNORECASE):
                                    self._log(f"‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞: –Ω–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤", "DEBUG")
                                    continue
                                # === –ö–û–ù–ï–¶ –§–ò–õ–¨–¢–†–ê–¶–ò–ò ===
                                tables_df.append(df)
                                self._log(f"‚úÖ –¢–∞–±–ª–∏—Ü–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", "SUCCESS")
                            else:
                                self._log(f"‚ö†Ô∏è –¢–∞–±–ª–∏—Ü–∞ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–∞ (–ø—É—Å—Ç–∞—è –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏)", "WARNING")
                        else:
                            self._log(f"‚ùå –¢–∞–±–ª–∏—Ü–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω–∞", "DEBUG")
                else:
                    self._log(f"‚ùå –¢–∞–±–ª–∏—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "DEBUG")
            except Exception as e:
                self._log(f"‚ùå –û—à–∏–±–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ {strategy_name}: {e}", "ERROR")
                continue
        self._log(f"üìä –ò–¢–û–ì–û —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page_num}: {len(tables_df)} –≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü")
        return tables_df    
    
    def _extract_tables_universal(self, page, page_num: int) -> List[pd.DataFrame]:
        tables_df = []
        strategies = [
            {"name": "–°–¢–†–ê–¢–ï–ì–ò–Ø –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ", "params": {}},
            {"name": "–õ–ò–ù–ò–ò+–õ–ò–ù–ò–ò", "params": {"vertical_strategy": "lines", "horizontal_strategy": "lines"}},
            {"name": "–¢–ï–ö–°–¢+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "text", "horizontal_strategy": "text"}},
            {"name": "–õ–ò–ù–ò–ò+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "lines", "horizontal_strategy": "text"}},
            {"name": "–¢–ï–ö–°–¢+–õ–ò–ù–ò–ò", "params": {"vertical_strategy": "text", "horizontal_strategy": "lines"}},
            {"name": "–°–ù–ò–ü–ü–ï–¢–´", "params": {"snap_tolerance": 5, "join_tolerance": 5}},
        ]
        for strategy in strategies:
            strategy_name = strategy["name"]
            strategy_params = strategy["params"]
            self._log(f"\nüéØ –ò–°–ü–û–õ–¨–ó–£–Æ –°–¢–†–ê–¢–ï–ì–ò–Æ: {strategy_name}")
            self._log(f"‚öôÔ∏è  –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: {strategy_params}")
            try:
                tables = page.extract_tables(strategy_params)
                if tables:
                    self._log(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(tables)}")
                    for table_idx, table in enumerate(tables):
                        table_name = f"–°—Ç—Ä–∞–Ω–∏—Ü–∞_{page_num}_{strategy_name}_–¢–∞–±–ª–∏—Ü–∞_{table_idx+1}"
                        self._log_table_info(table, table_name)
                        if table and self._is_valid_table(table):
                            df = self._table_to_dataframe(table, page_num, strategy_name, table_idx)
                            if not df.empty:
                                # === –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –ú–£–°–û–†–ù–´–• –¢–ê–ë–õ–ò–¶ ===
                                if df.shape[0] < 2 or df.shape[1] < 2:
                                    self._log(f"‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞: —Å–ª–∏—à–∫–æ–º –º–µ–ª–∫–∞—è ({df.shape})", "DEBUG")
                                    continue
                                
                                # –†–ê–°–®–ò–†–ï–ù–ù–´–ô –ü–û–ò–°–ö –ü–†–ò–ó–ù–ê–ö–û–í –†–ê–î–ò–ê–¢–û–†–û–í
                                text_flat = ' '.join(df.astype(str).values.flatten())
                                
                                # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –≤—Å–µ—è–¥–Ω–æ—Å—Ç–∏
                                radiator_patterns = (
                                    r'—Ä–∞–¥–∏–∞—Ç–æ—Ä|—Å—Ç–∞–ª—å–Ω–æ–π|–ø–∞–Ω–µ–ª—å–Ω—ã–π|–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω|'  # –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ—Ä–º–∏–Ω—ã
                                    r'radiator|heater|panel\s+heater|convector|'  # –ê–Ω–≥–ª–∏–π—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã
                                    
                                    # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ (—Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞–ø–∏—Å–∞–Ω–∏—è)
                                    r'—à—Ç|—à—Ç\.|–µ–¥|–µ–¥\.|pcs|pc|pieces|qty|quantity|q-?ty|–∫–æ–ª-?–≤–æ|–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ|'
                                    
                                    # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –º–æ–¥–µ–ª–µ–π —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤ (PURMO, Kermi, Buderus –∏ —Ç.–¥.)
                                    r'PURMO\s+[CHK]\s*\d{1,2}|'
                                    r'KERMI\s+[A-Z]\d{1,2}|'
                                    r'BUDERUS\s+[A-Z]\d{1,2}|'
                                    r'ROYAL\s+THERMO|'
                                    r'K-PROF|VK-PROF|CV\d{1,2}|HITERM|EVRA|'
                                    
                                    # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–∞–∑–º–µ—Ä–æ–≤ (300x800, 500√ó1000 –∏ —Ç.–¥.)
                                    r'\d{3,4}\s*[x—Ö√ó]\s*\d{3,4}|'
                                    
                                    # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                                    r'–Ω–∏–∂–Ω(?:–µ–µ|–∏–π)\s+–ø–æ–¥–∫–ª—é—á|–±–æ–∫–æ–≤\w+\s+–ø–æ–¥–∫–ª—é—á|–Ω–∏–∂–Ω–µ–µ|–±–æ–∫–æ–≤–æ–µ|'
                                    
                                    # –¢–∏–ø—ã –∏ —Å–µ—Ä–∏–∏
                                    r'—Ç–∏–ø\s*\d+|type\s*\d+|—Å–µ—Ä–∏—è|seria|'
                                    r'compact|classic|ventil|prado|purmo|kermi|royal|ftv|fto|ftk|'
                                    r'universal|–≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–π|hygiene|'
                                    
                                    # –ú–æ—â–Ω–æ—Å—Ç—å/—Ç–µ–ø–ª–æ (–í–∞—Ç—Ç—ã)
                                    r'–í—Ç|–≤–∞—Ç—Ç|watt|Q–Ω|Qp|'
                                    
                                    # –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –º–æ–¥–µ–ª–∏ –∏–∑ –≤–∞—à–µ–≥–æ PDF
                                    r'C\s*\d{1,2}s|H\s*\d{1,2}|'
                                    r'–†–ì-\d{1,3}-\d{1,3}-\d{1,2}'
                                )
                                
                                # –ú–Ø–ì–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: —Å—á–∏—Ç–∞–µ–º –±–∞–ª–ª—ã –∑–∞ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
                                score = 0
                                found_patterns = []
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
                                import re
                                if re.search(r'—Ä–∞–¥–∏–∞—Ç–æ—Ä|—Å—Ç–∞–ª—å–Ω–æ–π|–ø–∞–Ω–µ–ª—å–Ω—ã–π|–æ—Ç–æ–ø–∏—Ç–µ–ª—å–Ω', text_flat, re.IGNORECASE):
                                    score += 3
                                    found_patterns.append('—Ä–∞–¥–∏–∞—Ç–æ—Ä')
                                
                                if re.search(r'PURMO|KERMI|BUDERUS|ROYAL', text_flat, re.IGNORECASE):
                                    score += 2
                                    found_patterns.append('–±—Ä–µ–Ω–¥')
                                
                                if re.search(r'\d{3,4}\s*[x—Ö√ó]\s*\d{3,4}', text_flat, re.IGNORECASE):
                                    score += 2
                                    found_patterns.append('—Ä–∞–∑–º–µ—Ä—ã')
                                
                                if re.search(r'—à—Ç|—à—Ç\.|–µ–¥|–µ–¥\.|–∫–æ–ª-–≤–æ|–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', text_flat, re.IGNORECASE):
                                    score += 2
                                    found_patterns.append('–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ')
                                
                                if re.search(r'–í—Ç|–≤–∞—Ç—Ç|Q–Ω|Qp', text_flat, re.IGNORECASE):
                                    score += 1
                                    found_patterns.append('–º–æ—â–Ω–æ—Å—Ç—å')
                                
                                if re.search(r'C\s*\d{1,2}s|H\s*\d{1,2}', text_flat, re.IGNORECASE):
                                    score += 3  # –í—ã—Å–æ–∫–∏–π –±–∞–ª–ª –∑–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –º–æ–¥–µ–ª–∏ PURMO
                                    found_patterns.append('–º–æ–¥–µ–ª—å_PURMO')
                                
                                # –õ–æ–≥–∏—Ä—É–µ–º —á—Ç–æ –Ω–∞—à–ª–∏
                                if found_patterns:
                                    self._log(f"üîç –ù–∞–π–¥–µ–Ω—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤: {set(found_patterns)} (–±–∞–ª–ª—ã: {score})", "DEBUG")
                                
                                # –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –µ—Å–ª–∏ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤ –ò–õ–ò –º–æ–¥–µ–ª–∏ PURMO
                                should_keep_table = (score >= 3)  # –ú–∏–Ω–∏–º—É–º 3 –±–∞–ª–ª–∞
                                
                                if not should_keep_table:
                                    self._log(f"‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤ (–±–∞–ª–ª—ã: {score})", "DEBUG")
                                    continue
                                
                                self._log(f"‚úÖ –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–∏–Ω—è—Ç–∞ (–±–∞–ª–ª—ã: {score})", "SUCCESS")
                                # === –ö–û–ù–ï–¶ –§–ò–õ–¨–¢–†–ê–¶–ò–ò ===
                                
                                tables_df.append(df)
                                self._log(f"‚úÖ –¢–∞–±–ª–∏—Ü–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", "SUCCESS")
                            else:
                                self._log(f"‚ö†Ô∏è –¢–∞–±–ª–∏—Ü–∞ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–∞ (–ø—É—Å—Ç–∞—è –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏)", "WARNING")
                        else:
                            self._log(f"‚ùå –¢–∞–±–ª–∏—Ü–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω–∞", "DEBUG")
                else:
                    self._log(f"‚ùå –¢–∞–±–ª–∏—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "DEBUG")
            except Exception as e:
                self._log(f"‚ùå –û—à–∏–±–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ {strategy_name}: {e}", "ERROR")
                continue
        self._log(f"üìä –ò–¢–û–ì–û —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page_num}: {len(tables_df)} –≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü")
        return tables_df

    def _is_valid_table(self, table: List) -> bool:
        if not table or len(table) == 0:
            return False
        total_cells = sum(len(row) for row in table)
        non_empty_cells = sum(1 for row in table for cell in row if cell and str(cell).strip())
        fill_ratio = non_empty_cells / total_cells if total_cells > 0 else 0
        is_valid = (non_empty_cells >= 2 and fill_ratio > 0.1 and len(table) >= 1)
        self._log(f"üîç –ê–Ω–∞–ª–∏–∑ —Ç–∞–±–ª–∏—Ü—ã: {len(table)} —Å—Ç—Ä–æ–∫, {total_cells} —è—á–µ–µ–∫, {non_empty_cells} –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö ({fill_ratio:.1%})", "DEBUG")
        self._log(f"üîç –¢–∞–±–ª–∏—Ü–∞ –≤–∞–ª–∏–¥–Ω–∞: {is_valid}", "DEBUG")
        return is_valid

    def _table_to_dataframe(self, table: List, page_num: int, strategy_name: str, table_idx: int) -> pd.DataFrame:
        try:
            self._log(f"üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –≤ DataFrame...", "DEBUG")
            df = pd.DataFrame(table)
            original_shape = df.shape
            self._log(f"üìä –ò—Å—Ö–æ–¥–Ω—ã–π DataFrame: {original_shape}", "DEBUG")
            df = self._clean_table_dataframe(df)
            if df.empty:
                self._log(f"‚ùå DataFrame –ø—É—Å—Ç –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏", "DEBUG")
                return pd.DataFrame()
            df['_source_page'] = page_num
            df['_source_strategy'] = strategy_name
            df['_source_table_index'] = table_idx
            df['_row_index_original'] = range(len(df))
            self._log(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è: {original_shape} -> {df.shape}", "SUCCESS")
            return df
        except Exception as e:
            self._log(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}", "ERROR")
            return pd.DataFrame()

    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –ü–ê–†–°–ò–ù–ì –° –í–´–ë–û–†–û–ú –°–¢–†–ê–ù–ò–¶ ============
    def parse_to_dataframe_with_range(self, file_path: str, 
                                      start_page: int = 1, 
                                      end_page: Optional[int] = None,
                                      max_pages: Optional[int] = None) -> pd.DataFrame:
        """
        –ü–∞—Ä—Å–∏—Ç PDF –≤ DataFrame —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤—ã–±–æ—Ä–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param start_page: –ù–æ–º–µ—Ä –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å 1)
        :param end_page: –ù–æ–º–µ—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (None = –¥–æ –∫–æ–Ω—Ü–∞)
        :param max_pages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        try:
            import pdfplumber
        except ImportError:
            raise RuntimeError("‚ùå –ë–ò–ë–õ–ò–û–¢–ï–ö–ê PDFPLUMBER –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ê! –í—ã–ø–æ–ª–Ω–∏—Ç–µ: pip install pdfplumber")
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"‚ùå –§–ê–ô–õ –ù–ï –ù–ê–ô–î–ï–ù: {file_path}")
        
        self._log("üöÄ" * 50)
        self._log(f"üöÄ –ó–ê–ü–£–°–ö –ü–ê–†–°–ò–ù–ì–ê –° –í–´–ë–û–†–û–ú –°–¢–†–ê–ù–ò–¶: {os.path.basename(file_path)}")
        self._log(f"üìÅ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å: {file_path}")
        
        try:
            all_tables = []
            total_pages_processed = 0
            total_pages_skipped = 0
            
            with pdfplumber.open(file_path) as pdf:
                total_pages = len(pdf.pages)
                self._log(f"üìÑ –û–ë–ù–ê–†–£–ñ–ï–ù–û –°–¢–†–ê–ù–ò–¶ –í PDF: {total_pages}")
                
                # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü
                if start_page < 1:
                    start_page = 1
                    self._log(f"‚ö†Ô∏è  start_page –∏—Å–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ 1 (–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)")
                
                if end_page is None:
                    end_page = total_pages
                elif end_page > total_pages:
                    end_page = total_pages
                    self._log(f"‚ö†Ô∏è  end_page –∏—Å–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ {total_pages} (–º–∞–∫—Å–∏–º—É–º –≤ —Ñ–∞–π–ª–µ)")
                
                self._log(f"üìÑ –î–ò–ê–ü–ê–ó–û–ù –û–ë–†–ê–ë–û–¢–ö–ò: —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å {start_page} –ø–æ {end_page}")
                
                # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ max_pages
                pages_in_range = end_page - start_page + 1
                if max_pages and max_pages > 0 and pages_in_range > max_pages:
                    end_page = start_page + max_pages - 1
                    self._log(f"‚ö° –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï max_pages: –æ–±—Ä–∞–±–æ—Ç–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å {start_page} –ø–æ {end_page}")
                
                for page_num in range(start_page, end_page + 1):
                    page = pdf.pages[page_num - 1]
                    
                    # üî• –í–´–ó–´–í–ê–ï–ú –û–ë–†–ê–¢–ù–´–ô –í–´–ó–û–í –ü–†–û–ì–†–ï–°–°–ê (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
                    if self.progress_callback:
                        self.progress_callback(page_num - start_page + 1, end_page - start_page + 1)
                    
                    # üî• –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê: –°–¢–û–ò–¢ –õ–ò –û–ë–†–ê–ë–ê–¢–´–í–ê–¢–¨ –≠–¢–£ –°–¢–†–ê–ù–ò–¶–£?
                    if not self._should_process_page(page, page_num):
                        total_pages_skipped += 1
                        continue
                    
                    self._log(f"\nüìñ {'='*60}")
                    self._log(f"üìñ –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–†–ê–ù–ò–¶–´ {page_num}/{end_page} (–≤—Å–µ–≥–æ –≤ PDF: {total_pages})")
                    self._log(f"üìñ {'='*60}")
                    
                    page_tables = self._extract_tables_universal(page, page_num)
                    if page_tables:
                        all_tables.extend(page_tables)
                        total_pages_processed += 1
                    
                    # –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü—ã
                    if page_tables:
                        self._extract_and_analyze_text(page, page_num)
            
            # –°–≤–æ–¥–∫–∞ –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ
            self._log(f"\nüìä {'='*60}")
            self._log(f"üìä –°–í–û–î–ö–ê –ü–û –ü–ê–†–°–ò–ù–ì–£ –° –í–´–ë–û–†–û–ú –°–¢–†–ê–ù–ò–¶:")
            self._log(f"üìä –í—Å–µ–≥–æ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ PDF: {total_pages}")
            self._log(f"üìä –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω: {start_page}-{end_page}")
            self._log(f"üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_processed}")
            self._log(f"üìä –ü—Ä–æ–ø—É—â–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_skipped}")
            self._log(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(all_tables)}")
            self._log(f"üìä {'='*60}")
            
            if all_tables:
                # –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –ª—É—á—à–∏–µ —Ç–∞–±–ª–∏—Ü—ã (–±–µ–∑ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü)
                best_tables = []
                pages_processed = set()
                for table in all_tables:
                    page = table['_source_page'].iloc[0] if '_source_page' in table.columns else 0
                    if page not in pages_processed:
                        best_tables.append(table)
                        pages_processed.add(page)
                
                self._log(f"üìä –í—ã–±—Ä–∞–Ω–æ {len(best_tables)} –ª—É—á—à–∏—Ö —Ç–∞–±–ª–∏—Ü –∏–∑ {len(all_tables)}")
                result_df = self._merge_all_tables(best_tables)
            else:
                result_df = pd.DataFrame()
            
            result_df = self._replace_na_values(result_df)
            self._analyze_final_result(result_df, file_path)
            
            if not result_df.empty:
                self._log(f"‚úÖ –£–°–ü–ï–•! –°–û–ó–î–ê–ù DATAFRAME: {result_df.shape}")
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–∞–¥–∏–∞—Ç–æ—Ä—ã –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                radiators = self.extract_radiators_from_dataframe(result_df)
                self._log(f"‚úÖ –ò–∑–≤–ª–µ—á–µ–Ω–æ {len(radiators)} –ø–æ–∑–∏—Ü–∏–π —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤")
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä—ã –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤
                if radiators:
                    self._log("üìã –ü—Ä–∏–º–µ—Ä—ã –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤:")
                    for i, rad in enumerate(radiators[:5]):
                        self._log(f"   {i+1}. {rad['name']} - {rad['quantity']} —à—Ç. (—Å—Ç—Ä. {rad['source_page']})")
            else:
                self._log("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –í PDF –ù–ï –ù–ê–ô–î–ï–ù–û –¢–ê–ë–õ–ò–ß–ù–´–• –î–ê–ù–ù–´–•")
            
            return result_df
            
        except Exception as e:
            error_msg = f"‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –ü–ê–†–°–ò–ù–ì–ê {file_path}:\n{str(e)}\n{traceback.format_exc()}"
            self._log(error_msg, "ERROR")
            raise RuntimeError(error_msg)

    def _clean_table_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        if df.empty:
            return df
        original_shape = df.shape
        self._log(f"üßπ –ù–∞—á–∞–ª–æ –æ—á–∏—Å—Ç–∫–∏ DataFrame: {original_shape}", "DEBUG")
        df = df.astype(str)
        df = df.apply(lambda x: x.str.strip())
        df = df.replace({
            '': '', 'nan': '', 'None': '', '<NA>': '', 'NaT': '',
            'NULL': '', 'null': '', 'NaN': '', 'N/A': '', 'n/a': ''
        })
        mask_rows = df.astype(str).apply(lambda x: x.str.strip() != '').any(axis=1)
        df = df[mask_rows]
        mask_cols = df.astype(str).apply(lambda x: x.str.strip() != '').any(axis=0)
        df = df.loc[:, mask_cols]
        if not df.empty:
            df = df.reset_index(drop=True)
            new_columns = [f"Col_{i}" for i in range(len(df.columns))]
            df.columns = new_columns
        self._log(f"‚úÖ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {original_shape} -> {df.shape}", "SUCCESS")
        return df

    def _extract_and_analyze_text(self, page, page_num: int):
        try:
            text = page.extract_text()
            if text:
                lines = text.split('\n')
                self._log(f"üìù –¢–µ–∫—Å—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page_num}: {len(lines)} —Å—Ç—Ä–æ–∫")
                keywords = ['—Ä–∞–¥–∏–∞—Ç–æ—Ä', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω—ã–π', 'K-PROF', 'VK-PROF', 'Buderus', '—Ç–µ–ø–ª–æ', '–æ—Ç–æ–ø–ª–µ–Ω–∏–µ']
                found_keywords = []
                for line in lines[:10]:
                    for keyword in keywords:
                        if keyword.lower() in line.lower():
                            found_keywords.append(keyword)
                if found_keywords:
                    self._log(f"üîë –ù–∞–π–¥–µ–Ω—ã –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: {list(set(found_keywords))}", "SUCCESS")
                for i, line in enumerate(lines[:3]):
                    if line.strip():
                        self._log(f"   üìÑ –°—Ç—Ä–æ–∫–∞ {i+1}: {line[:100]}...", "DEBUG")
        except Exception as e:
            self._log(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–∫—Å—Ç–∞: {e}", "DEBUG")

    def _merge_all_tables(self, all_tables: List[pd.DataFrame]) -> pd.DataFrame:
        if not all_tables:
            return pd.DataFrame()
        if len(all_tables) == 1:
            return all_tables[0]
        self._log(f"\nüîó –û–ë–™–ï–î–ò–ù–ï–ù–ò–ï {len(all_tables)} –¢–ê–ë–õ–ò–¶...")
        try:
            result = pd.concat(all_tables, ignore_index=True, sort=False)
            self._log(f"‚úÖ –ü—Ä–æ—Å—Ç–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ: {result.shape}", "SUCCESS")
            result = self._final_cleanup(result)
            return result
        except Exception as e:
            self._log(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è: {e}", "ERROR")
            try:
                result = all_tables[0]
                for i, table in enumerate(all_tables[1:], 1):
                    try:
                        result = pd.concat([result, table], ignore_index=True)
                        self._log(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ {i+1}", "DEBUG")
                    except Exception as e2:
                        self._log(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã {i+1}: {e2}", "DEBUG")
                        continue
                return result
            except:
                return all_tables[0] if all_tables else pd.DataFrame()

    def _final_cleanup(self, df: pd.DataFrame) -> pd.DataFrame:
        if df.empty:
            return df
        original_shape = df.shape
        mask = df.astype(str).apply(lambda x: x.str.strip() != '').any(axis=1)
        df = df[mask]
        mask_cols = df.astype(str).apply(lambda x: x.str.strip() != '').any(axis=0)
        df = df.loc[:, mask_cols]
        df = df.reset_index(drop=True)
        self._log(f"‚úÖ –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {original_shape} -> {df.shape}", "SUCCESS")
        return df

    def _replace_na_values(self, df: pd.DataFrame) -> pd.DataFrame:
        if df.empty:
            return df
        self._log(f"\nüõ°Ô∏è  –ó–ê–©–ò–¢–ê –û–¢ PD.NA –í DATAFRAME: {df.shape}")
        df = df.fillna('')
        na_patterns = ['nan', 'None', 'NoneType', '<NA>', 'NaT', 'NULL', 'null', 'NaN', 'N/A', 'n/a']
        for pattern in na_patterns:
            count = (df == pattern).sum().sum()
            if count > 0:
                self._log(f"   üîÑ –ó–∞–º–µ–Ω—è—é '{pattern}': {count} –∑–Ω–∞—á–µ–Ω–∏–π")
        df = df.replace(na_patterns, '')
        for col in df.columns:
            df[col] = df[col].astype(str).str.strip()
        self._log(f"‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç pd.NA –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ", "SUCCESS")
        return df

    def _analyze_final_result(self, df: pd.DataFrame, file_path: str):
        self._log(f"\nüìä {'='*60}")
        self._log(f"üìä –î–ï–¢–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó –§–ò–ù–ê–õ–¨–ù–û–ì–û –†–ï–ó–£–õ–¨–¢–ê–¢–ê")
        self._log(f"üìä {'='*60}")
        if df.empty:
            self._log("‚ùå DataFrame –ø—É—Å—Ç - –∞–Ω–∞–ª–∏–∑ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω")
            return
        self._log(f"üìè –†–ê–ó–ú–ï–†: {df.shape}")
        self._log(f"üî¢ –°—Ç—Ä–æ–∫: {len(df)}, –ö–æ–ª–æ–Ω–æ–∫: {len(df.columns)}")
        for col in df.columns:
            non_empty = (df[col].str.strip() != '').sum()
            unique_count = df[col].nunique()
            sample_values = df[col].head(3).tolist()
            self._log(f"   {col}: {non_empty}/{len(df)} –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, {unique_count} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö")
            self._log(f"     –ü—Ä–∏–º–µ—Ä—ã: {sample_values}")
        radiator_keywords = ['K-PROF', 'VK-PROF', '—Ä–∞–¥–∏–∞—Ç–æ—Ä', 'Buderus', '—Ä–∞–¥–∏–∞—Ç–æ—Ä–Ω—ã–π']
        for keyword in radiator_keywords:
            count = df.astype(str).apply(lambda x: x.str.contains(keyword, case=False, na=False)).sum().sum()
            if count > 0:
                self._log(f"   ‚úÖ '{keyword}': –Ω–∞–π–¥–µ–Ω–æ {count} —É–ø–æ–º–∏–Ω–∞–Ω–∏–π", "SUCCESS")
            else:
                self._log(f"   ‚ùå '{keyword}': –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "DEBUG")
        if '_source_page' in df.columns:
            pages_used = df['_source_page'].nunique()
            self._log(f"üìÑ –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–û –°–¢–†–ê–ù–ò–¶: {pages_used}")
        self.analysis_results[file_path] = {
            'shape': df.shape,
            'columns': list(df.columns),
            'total_rows': len(df),
            'non_empty_rows': (df.astype(str).apply(lambda x: x.str.strip() != '')).any(axis=1).sum(),
            'timestamp': datetime.now().isoformat()
        }

    def auto_detect_column_mapping(self, df: pd.DataFrame) -> Dict[str, str]:
        self._log(f"\nüîç –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ö–û–õ–û–ù–û–ö:")
        mapping = {}
        column_patterns = {
            '–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ': ['–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ', 'name', '–æ–ø–∏—Å–∞–Ω–∏–µ', 'description', '—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞'],
            '—Ç–∏–ø': ['—Ç–∏–ø', '–º–∞—Ä–∫–∞', 'type', 'model'],
            '–∫–æ–¥': ['–∫–æ–¥', '–∞—Ä—Ç–∏–∫—É–ª', 'code', 'article'],
            '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ': ['–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', '–∫–æ–ª-–≤–æ', 'count', 'quantity'],
            '–µ–¥–∏–Ω–∏—Ü–∞': ['–µ–¥–∏–Ω–∏—Ü–∞', '–µ–¥', 'unit'],
            '–º–∞—Å—Å–∞': ['–º–∞—Å—Å–∞', 'weight', '–≤–µ—Å']
        }
        for col in df.columns:
            col_lower = str(col).lower()
            self._log(f"   –ê–Ω–∞–ª–∏–∑ –∫–æ–ª–æ–Ω–∫–∏ '{col}': {col_lower}")
            for field_name, patterns in column_patterns.items():
                if any(pattern in col_lower for pattern in patterns):
                    mapping[col] = field_name
                    self._log(f"     ‚úÖ –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ —Å '{field_name}'", "SUCCESS")
                    break
            else:
                self._log(f"     ‚ùå –ù–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞", "DEBUG")
        self._log(f"üìã –ò–¢–û–ì–û —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {len(mapping)} –∫–æ–ª–æ–Ω–æ–∫")
        return mapping

    def batch_process_directory(self, directory_path: str = "."):
        self._log(f"\nüìÇ –ü–ê–ö–ï–¢–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê –î–ò–†–ï–ö–¢–û–†–ò–ò: {directory_path}")
        if not os.path.exists(directory_path):
            self._log(f"‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {directory_path}", "ERROR")
            return
        pdf_files = glob.glob(os.path.join(directory_path, "*.pdf"))
        self._log(f"üìÑ –ù–∞–π–¥–µ–Ω–æ PDF —Ñ–∞–π–ª–æ–≤: {len(pdf_files)}")
        if not pdf_files:
            self._log("‚ùå PDF —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "ERROR")
            return
        results = {}
        for pdf_file in pdf_files:
            try:
                self._log(f"\n{'='*80}")
                self._log(f"üîÑ –û–ë–†–ê–ë–û–¢–ö–ê –§–ê–ô–õ–ê: {os.path.basename(pdf_file)}")
                self._log(f"{'='*80}")
                df = self.parse_to_dataframe(pdf_file)
                if not df.empty:
                    results[pdf_file] = {
                        'status': 'success',
                        'shape': df.shape
                    }
                else:
                    results[pdf_file] = {
                        'status': 'empty',
                        'shape': (0, 0)
                    }
            except Exception as e:
                self._log(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞ {pdf_file}: {e}", "ERROR")
                results[pdf_file] = {
                    'status': 'error',
                    'error': str(e)
                }
        success_count = sum(1 for r in results.values() if r['status'] == 'success')
        empty_count = sum(1 for r in results.values() if r['status'] == 'empty')
        error_count = sum(1 for r in results.values() if r['status'] == 'error')
        self._log(f"\nüìä –°–í–û–î–ù–´–ô –û–¢–ß–ï–¢ –ü–û –ü–ê–ö–ï–¢–ù–û–ô –û–ë–†–ê–ë–û–¢–ö–ï:")
        self._log(f"‚úÖ –£—Å–ø–µ—à–Ω–æ: {success_count} —Ñ–∞–π–ª–æ–≤")
        self._log(f"‚ö†Ô∏è  –ü—É—Å—Ç—ã–µ: {empty_count} —Ñ–∞–π–ª–æ–≤") 
        self._log(f"‚ùå –û—à–∏–±–∫–∏: {error_count} —Ñ–∞–π–ª–æ–≤")
        return results

    def parse_optimized(self, file_path: str, 
                    start_page: int = 1, 
                    end_page: Optional[int] = None,
                    max_pages: Optional[int] = None,
                    pages: Optional[List[int]] = None) -> pd.DataFrame:
        """
        –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param start_page: –ù–æ–º–µ—Ä –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å 1)
        :param end_page: –ù–æ–º–µ—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (None = –¥–æ –∫–æ–Ω—Ü–∞)
        :param max_pages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        :param pages: –°–ø–∏—Å–æ–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (–Ω–æ–º–µ—Ä–∞ —Å 1)
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        try:
            import pdfplumber
        except ImportError:
            raise RuntimeError("‚ùå –ë–ò–ë–õ–ò–û–¢–ï–ö–ê PDFPLUMBER –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ê!")
        
        self._log("üöÄ –ó–ê–ü–£–°–ö –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û –ü–ê–†–°–ò–ù–ì–ê")
        self._log(f"üìÅ –§–∞–π–ª: {os.path.basename(file_path)}")
        
        # –õ–æ–≥–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        if start_page != 1:
            self._log(f"üìÑ –ù–∞—á–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {start_page}")
        if end_page:
            self._log(f"üìÑ –ö–æ–Ω–µ—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {end_page}")
        if max_pages:
            self._log(f"‚ö° –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ: –Ω–µ –±–æ–ª–µ–µ {max_pages} —Å—Ç—Ä–∞–Ω–∏—Ü")
            
        all_tables = []
        try:
            with pdfplumber.open(file_path) as pdf:
                total_pages_in_pdf = len(pdf.pages)
                self._log(f"üìÑ –ù–∞–π–¥–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_in_pdf}")
                
                # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü
                if start_page < 1:
                    start_page = 1
                
                if end_page is None:
                    end_page = total_pages_in_pdf
                elif end_page > total_pages_in_pdf:
                    end_page = total_pages_in_pdf
                
                # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ max_pages
                pages_in_range = end_page - start_page + 1
                if max_pages and max_pages > 0 and pages_in_range > max_pages:
                    end_page = start_page + max_pages - 1
                
                self._log(f"üìÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {start_page}-{end_page}")
                
                for page_num in range(start_page, end_page + 1):
                    page = pdf.pages[page_num - 1]
                    
                    # üî• –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–¢–†–ê–ù–ò–¶–´ (–¥–æ–±–∞–≤–ª–µ–Ω–æ)
                    if not self._should_process_page(page, page_num):
                        continue
                    
                    self._log(f"\nüìñ –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–†–ê–ù–ò–¶–´ {page_num}/{end_page}")
                    strategies = [
                        {"name": "–¢–ï–ö–°–¢+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "text", "horizontal_strategy": "text", "snap_tolerance": 8}},
                        {"name": "–õ–ò–ù–ò–ò+–¢–ï–ö–°–¢", "params": {"vertical_strategy": "lines", "horizontal_strategy": "text", "snap_tolerance": 8}},
                    ]
                    best_table_for_page = None
                    for strategy in strategies:
                        strategy_name = strategy["name"]
                        strategy_params = strategy["params"]
                        self._log(f"üéØ –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é: {strategy_name}")
                        try:
                            tables = page.extract_tables(strategy_params)
                            if tables:
                                for table_idx, table in enumerate(tables):
                                    if table and self._is_valid_table(table):
                                        df = self._table_to_dataframe(table, page_num, strategy_name, table_idx)
                                        if not df.empty:
                                            df = self._fix_ocr_artifacts(df)
                                            if best_table_for_page is None or len(df) > len(best_table_for_page):
                                                best_table_for_page = df
                                                self._log(f"‚úÖ –ù–∞–π–¥–µ–Ω–∞ –ª—É—á—à–∞—è —Ç–∞–±–ª–∏—Ü–∞: {df.shape}")
                        except Exception as e:
                            self._log(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ {strategy_name}: {e}", "DEBUG")
                            continue
                    if best_table_for_page is not None:
                        all_tables.append(best_table_for_page)
                        self._log(f"üìä –î–æ–±–∞–≤–ª–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page_num}: {best_table_for_page.shape}")
                    else:
                        self._log(f"‚ö†Ô∏è –ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page_num} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü")
            
            self._log(f"\nüìä –í–°–ï–ì–û –ù–ê–ô–î–ï–ù–û –¢–ê–ë–õ–ò–¶: {len(all_tables)}")
            if not all_tables:
                self._log("‚ùå –ù–µ—Ç —Ç–∞–±–ª–∏—Ü –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                return pd.DataFrame()
            
            result_df = pd.concat(all_tables, ignore_index=True)
            result_df = self._final_cleanup(result_df)
            result_df = self._replace_na_values(result_df)
            self._analyze_final_result(result_df, file_path)
            
            if result_df.empty:
                self._log("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –í PDF –ù–ï –ù–ê–ô–î–ï–ù–û –¢–ê–ë–õ–ò–ß–ù–´–• –î–ê–ù–ù–´–•")
            else:
                self._log(f"‚úÖ –£–°–ü–ï–•! –°–û–ó–î–ê–ù DATAFRAME: {result_df.shape}")
            
            return result_df
            
        except Exception as e:
            error_msg = f"‚ùå –û–®–ò–ë–ö–ê –ü–ê–†–°–ò–ù–ì–ê: {str(e)}\n{traceback.format_exc()}"
            self._log(error_msg, "ERROR")
            raise RuntimeError(error_msg)

    def _fix_ocr_artifacts(self, df: pd.DataFrame) -> pd.DataFrame:
        self._log("üîß –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï OCR-–ê–†–¢–ï–§–ê–ö–¢–û–í...")
        fixed_count = 0
        for col in df.columns:
            if df[col].dtype == 'object':
                for idx in df.index:
                    original_value = str(df.at[idx, col])
                    if original_value and any(original_value[i] == original_value[i+1] for i in range(len(original_value)-1) if original_value[i].isalpha()):
                        fixed_value = self._fix_double_chars(original_value)
                        if fixed_value != original_value:
                            df.at[idx, col] = fixed_value
                            fixed_count += 1
        self._log(f"   üîÑ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ {fixed_count} –∑–Ω–∞—á–µ–Ω–∏–π —Å OCR-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞–º–∏")
        return df

    def _fix_double_chars(self, text: str) -> str:
        if not text or len(text) < 2:
            return text
        result = []
        i = 0
        while i < len(text):
            if (i + 1 < len(text) and text[i] == text[i+1] and text[i].isalpha()):
                result.append(text[i])
                i += 2
            else:
                result.append(text[i])
                i += 1
        return ''.join(result)

    def quick_test(self, file_path: str):
        self._log("‚ö° –ë–´–°–¢–†–´–ô –¢–ï–°–¢ –ü–ê–†–°–ò–ù–ì–ê")
        import pdfplumber
        with pdfplumber.open(file_path) as pdf:
            page = pdf.pages[0]
            tables = page.extract_tables({"vertical_strategy": "text", "horizontal_strategy": "text"})
            if tables and tables[0]:
                df = pd.DataFrame(tables[0])
                df = df.replace(r'^\s*$', '', regex=True)
                df = df.fillna('')
                df = df.loc[df.astype(bool).any(axis=1)]
                df = df.loc[:, df.astype(bool).any(axis=0)]
                df = self._fix_ocr_artifacts(df)
                self._log(f"‚ö° –†–µ–∑—É–ª—å—Ç–∞—Ç –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∞: {df.shape}")
                self._log("üìã –ü–µ—Ä–≤—ã–µ 5 —Å—Ç—Ä–æ–∫:")
                for i in range(min(5, len(df))):
                    row_preview = [str(cell)[:30] for cell in df.iloc[i].values if str(cell).strip()]
                    self._log(f"   –°—Ç—Ä–æ–∫–∞ {i}: {row_preview}")
                return df
        return pd.DataFrame()

    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –î–ò–ê–õ–û–ì –í–´–ë–û–†–ê –°–¢–†–ê–ù–ò–¶ ============
    def show_page_selection_dialog(self, file_path: str) -> Optional[Dict[str, Any]]:
        """
        –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥–æ–≤–æ–µ –æ–∫–Ω–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :return: –°–ª–æ–≤–∞—Ä—å —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∏–ª–∏ None –µ—Å–ª–∏ –æ—Ç–º–µ–Ω–∞
        """
        try:
            import tkinter as tk
            from tkinter import ttk, messagebox
        except ImportError:
            self._log("‚ùå Tkinter –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã start_page/end_page –Ω–∞–ø—Ä—è–º—É—é", "ERROR")
            return None
        
        try:
            import pdfplumber
        except ImportError:
            self._log("‚ùå pdfplumber –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", "ERROR")
            return None
        
        if not os.path.exists(file_path):
            self._log(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}", "ERROR")
            return None
        
        result = {
            'start_page': 1,
            'end_page': None,
            'max_pages': None,
            'use_lazy_loading': False,
            'method': 'standard'  # 'standard', 'optimized', 'lazy'
        }
        
        # –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ –æ–∫–Ω–æ
        root = tk.Tk()
        root.title(f"–í—ã–±–æ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞: {os.path.basename(file_path)}")
        root.geometry("700x500")
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ PDF
        try:
            with pdfplumber.open(file_path) as pdf:
                total_pages = len(pdf.pages)
                # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–≤—å—é –ø–µ—Ä–≤—ã—Ö 5 —Å—Ç—Ä–∞–Ω–∏—Ü
                page_previews = []
                for i in range(min(5, total_pages)):
                    page = pdf.pages[i]
                    text = page.extract_text()
                    if text:
                        preview = text[:150].replace('\n', ' ') + "..." if len(text) > 150 else text
                    else:
                        preview = "[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ/—á–µ—Ä—Ç–µ–∂ - –º–∞–ª–æ —Ç–µ–∫—Å—Ç–∞]"
                    page_previews.append((i+1, preview))
        except Exception as e:
            self._log(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è PDF: {e}", "ERROR")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å PDF —Ñ–∞–π–ª:\n{str(e)}")
            root.destroy()
            return None
        
        # –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±–æ—Ä–∞
        start_var = tk.StringVar(value="1")
        end_var = tk.StringVar(value=str(total_pages))
        max_pages_var = tk.StringVar(value="")
        use_lazy_var = tk.BooleanVar(value=False)
        method_var = tk.StringVar(value="standard")
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        def update_range():
            try:
                start = int(start_var.get())
                end = int(end_var.get())
                max_pages = max_pages_var.get()
                
                if start < 1:
                    start_var.set("1")
                if start > total_pages:
                    start_var.set(str(total_pages))
                
                if end < 1:
                    end_var.set("1")
                if end > total_pages:
                    end_var.set(str(total_pages))
                
                if max_pages:
                    max_val = int(max_pages)
                    if max_val < 1:
                        max_pages_var.set("1")
            except:
                pass
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤—Å–µ—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
        def select_all_pages():
            start_var.set("1")
            end_var.set(str(total_pages))
            max_pages_var.set("")
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä–≤—ã—Ö N —Å—Ç—Ä–∞–Ω–∏—Ü
        def select_first_n():
            n = min(20, total_pages)
            start_var.set("1")
            end_var.set(str(n))
            max_pages_var.set(str(n))
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—ã–±–æ—Ä–∞
        def apply_selection():
            try:
                result['start_page'] = int(start_var.get())
                result['end_page'] = int(end_var.get())
                
                if max_pages_var.get():
                    result['max_pages'] = int(max_pages_var.get())
                else:
                    result['max_pages'] = None
                
                result['use_lazy_loading'] = use_lazy_var.get()
                result['method'] = method_var.get()
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
                if result['start_page'] > result['end_page']:
                    messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–∞—á–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ –∫–æ–Ω–µ—á–Ω–æ–π")
                    return
                
                if result['start_page'] < 1 or result['end_page'] > total_pages:
                    messagebox.showerror("–û—à–∏–±–∫–∞", f"–î–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ {total_pages}")
                    return
                
                root.destroy()
                
            except ValueError:
                messagebox.showerror("–û—à–∏–±–∫–∞", "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —á–∏—Å–ª–∞")
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã
        def cancel_selection():
            nonlocal result
            result = None
            root.destroy()
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–µ
        info_frame = ttk.LabelFrame(main_frame, text="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ PDF", padding="10")
        info_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(info_frame, text=f"–§–∞–π–ª: {os.path.basename(file_path)}", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky=tk.W)
        ttk.Label(info_frame, text=f"–í—Å–µ–≥–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages}", font=('Arial', 10)).grid(row=1, column=0, sticky=tk.W)
        
        # –ü—Ä–µ–≤—å—é —Å—Ç—Ä–∞–Ω–∏—Ü
        if page_previews:
            preview_frame = ttk.LabelFrame(main_frame, text="–ü—Ä–µ–≤—å—é –ø–µ—Ä–≤—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü", padding="10")
            preview_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
            
            for i, (page_num, preview) in enumerate(page_previews):
                ttk.Label(preview_frame, text=f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num}:", font=('Arial', 9, 'bold')).grid(row=i, column=0, sticky=tk.W, pady=(5,0))
                preview_text = tk.Text(preview_frame, height=2, width=60, wrap=tk.WORD)
                preview_text.grid(row=i, column=1, sticky=tk.W, pady=(5,0))
                preview_text.insert('1.0', preview)
                preview_text.config(state=tk.DISABLED)
        
        # –í—ã–±–æ—Ä –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        range_frame = ttk.LabelFrame(main_frame, text="–í—ã–±–æ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞", padding="10")
        range_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(range_frame, text="–ù–∞—á–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞:").grid(row=0, column=0, sticky=tk.W, pady=5)
        start_spinbox = ttk.Spinbox(range_frame, from_=1, to=total_pages, textvariable=start_var, width=10)
        start_spinbox.grid(row=0, column=1, sticky=tk.W, pady=5, padx=(5, 20))
        
        ttk.Label(range_frame, text="–ö–æ–Ω–µ—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞:").grid(row=0, column=2, sticky=tk.W, pady=5)
        end_spinbox = ttk.Spinbox(range_frame, from_=1, to=total_pages, textvariable=end_var, width=10)
        end_spinbox.grid(row=0, column=3, sticky=tk.W, pady=5)
        
        ttk.Label(range_frame, text="–ú–∞–∫—Å. —Å—Ç—Ä–∞–Ω–∏—Ü (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ):").grid(row=1, column=0, sticky=tk.W, pady=5)
        max_entry = ttk.Entry(range_frame, textvariable=max_pages_var, width=10)
        max_entry.grid(row=1, column=1, sticky=tk.W, pady=5, padx=(5, 20))
        
        # –ë—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞
        button_frame = ttk.Frame(range_frame)
        button_frame.grid(row=2, column=0, columnspan=4, pady=10)
        
        ttk.Button(button_frame, text="–í—Å–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã", command=select_all_pages, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="–ü–µ—Ä–≤—ã–µ 20 —Å—Ç—Ä–∞–Ω–∏—Ü", command=select_first_n, width=15).pack(side=tk.LEFT, padx=2)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        settings_frame = ttk.LabelFrame(main_frame, text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞", padding="10")
        settings_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(settings_frame, text="–ú–µ—Ç–æ–¥ –ø–∞—Ä—Å–∏–Ω–≥–∞:").grid(row=0, column=0, sticky=tk.W, pady=5)
        method_combo = ttk.Combobox(settings_frame, textvariable=method_var, 
                                   values=["standard", "optimized", "lazy"], 
                                   state="readonly", width=15)
        method_combo.grid(row=0, column=1, sticky=tk.W, pady=5, padx=(5, 20))
        
        lazy_check = ttk.Checkbutton(settings_frame, text="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–µ–Ω–∏–≤—É—é –∑–∞–≥—Ä—É–∑–∫—É (—ç–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å)", 
                                    variable=use_lazy_var)
        lazy_check.grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=5)
        
        # –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=4, column=0, columnspan=2, pady=20)
        
        ttk.Button(action_frame, text="–ù–∞—á–∞—Ç—å –ø–∞—Ä—Å–∏–Ω–≥", command=apply_selection, 
                  style="Accent.TButton").pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="–û—Ç–º–µ–Ω–∞", command=cancel_selection).pack(side=tk.LEFT, padx=5)
        
        # –°—Ç–∏–ª—å –¥–ª—è –∞–∫—Ü–µ–Ω—Ç–Ω–æ–π –∫–Ω–æ–ø–∫–∏
        style = ttk.Style()
        style.configure("Accent.TButton", foreground="white", background="#0078D7")
        
        # –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è
        start_spinbox.bind('<FocusOut>', lambda e: update_range())
        end_spinbox.bind('<FocusOut>', lambda e: update_range())
        max_entry.bind('<FocusOut>', lambda e: update_range())
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≥–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
        root.mainloop()
        
        return result
    
    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –ü–ê–†–°–ò–ù–ì –° –î–ò–ê–õ–û–ì–û–ú –í–´–ë–û–†–ê ============
    def parse_with_dialog(self, file_path: str) -> pd.DataFrame:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –¥–ª—è –≤—ã–∑–æ–≤–∞ –∏–∑ GUI - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        self._log(f"\n{'='*80}")
        self._log(f"üîÑ –ó–ê–ü–£–°–ö –ü–ê–†–°–ò–ù–ì–ê –° –î–ò–ê–õ–û–ì–û–ú –í–´–ë–û–†–ê –°–¢–†–ê–ù–ò–¶")
        self._log(f"üìÅ –§–∞–π–ª: {file_path}")
        self._log(f"{'='*80}")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        selection = self.show_page_selection_dialog(file_path)
        
        if selection is None:
            self._log("‚ùå –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–º–µ–Ω–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            return pd.DataFrame()
        
        self._log(f"üìã –í–´–ë–†–ê–ù–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´:")
        self._log(f"   –ù–∞—á–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {selection['start_page']}")
        self._log(f"   –ö–æ–Ω–µ—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {selection['end_page']}")
        self._log(f"   –ú–∞–∫—Å. —Å—Ç—Ä–∞–Ω–∏—Ü: {selection['max_pages']}")
        self._log(f"   –ú–µ—Ç–æ–¥: {selection['method']}")
        self._log(f"   –õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞: {selection['use_lazy_loading']}")
        
        # –í—ã–±–∏—Ä–∞–µ–º –º–µ—Ç–æ–¥ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±–æ—Ä–∞
        if selection['method'] == 'lazy' or selection['use_lazy_loading']:
            self._log("‚ö° –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ —Å –ª–µ–Ω–∏–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–æ–π")
            return self.parse_with_lazy_loading(
                file_path,
                start_page=selection['start_page'],
                end_page=selection['end_page'],
                max_pages=selection['max_pages']
            )
        elif selection['method'] == 'optimized':
            self._log("‚ö° –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥")
            return self.parse_optimized(
                file_path,
                start_page=selection['start_page'],
                end_page=selection['end_page'],
                max_pages=selection['max_pages']
            )
        else:
            self._log("‚ö° –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–µ—Ç–æ–¥")
            return self.parse_to_dataframe_with_range(
                file_path,
                start_page=selection['start_page'],
                end_page=selection['end_page'],
                max_pages=selection['max_pages']
            )

    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –£–ú–ù–´–ô –ü–ê–†–°–ò–ù–ì –° –ê–í–¢–û–í–´–ë–û–†–û–ú ============
    def smart_parse(self, file_path: str, show_dialog: bool = True) -> pd.DataFrame:
        """
        –£–º–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param show_dialog: –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ª–∏ –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        if show_dialog:
            return self.parse_with_dialog(file_path)
        else:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            self._log("‚ö° –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–ø–µ—Ä–≤—ã–µ 50 —Å—Ç—Ä–∞–Ω–∏—Ü)")
            return self.parse_to_dataframe(file_path, max_pages=50)
    
    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –ë–´–°–¢–†–´–ô –ü–ê–†–°–ò–ù–ì –¢–û–õ–¨–ö–û –° –¢–ê–ë–õ–ò–¶–ê–ú–ò ============
    def quick_parse_only_tables(self, file_path: str) -> pd.DataFrame:
        """
        –ë—ã—Å—Ç—Ä—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä)
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        self._log("‚ö° –ó–ê–ü–£–°–ö –ë–´–°–¢–†–û–ì–û –ü–ê–†–°–ò–ù–ì–ê –¢–û–õ–¨–ö–û –°–¢–†–ê–ù–ò–¶ –° –¢–ê–ë–õ–ò–¶–ê–ú–ò")
        
        try:
            import pdfplumber
        except ImportError:
            raise RuntimeError("‚ùå –ë–ò–ë–õ–ò–û–¢–ï–ö–ê PDFPLUMBER –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ê!")
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"‚ùå –§–ê–ô–õ –ù–ï –ù–ê–ô–î–ï–ù: {file_path}")
        
        all_tables = []
        pages_with_tables = []
        
        try:
            with pdfplumber.open(file_path) as pdf:
                total_pages = len(pdf.pages)
                self._log(f"üìÑ –í—Å–µ–≥–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages}")
                self._log("üîç –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—â—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏...")
                
                # –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –≤—Å–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏
                for page_num in range(1, total_pages + 1):
                    page = pdf.pages[page_num - 1]
                    
                    if self._should_process_page(page, page_num):
                        pages_with_tables.append(page_num)
                
                self._log(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏: {len(pages_with_tables)}")
                
                if not pages_with_tables:
                    self._log("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏ —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤")
                    return pd.DataFrame()
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏
                for i, page_num in enumerate(pages_with_tables):
                    page = pdf.pages[page_num - 1]
                    
                    if self.progress_callback:
                        self.progress_callback(i + 1, len(pages_with_tables))
                    
                    self._log(f"üìñ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å —Ç–∞–±–ª–∏—Ü–µ–π {i+1}/{len(pages_with_tables)}: —Å—Ç—Ä. {page_num}")
                    
                    page_tables = self._extract_tables_universal(page, page_num)
                    if page_tables:
                        all_tables.extend(page_tables)
                
                self._log(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(all_tables)}")
                
                if all_tables:
                    result_df = self._merge_all_tables(all_tables)
                    result_df = self._replace_na_values(result_df)
                    self._analyze_final_result(result_df, file_path)
                    return result_df
                else:
                    return pd.DataFrame()
                    
        except Exception as e:
            error_msg = f"‚ùå –û–®–ò–ë–ö–ê –ë–´–°–¢–†–û–ì–û –ü–ê–†–°–ò–ù–ì–ê: {str(e)}\n{traceback.format_exc()}"
            self._log(error_msg, "ERROR")
            raise RuntimeError(error_msg)

    # ============ –ù–û–í–´–ô –ö–õ–ê–°–° –î–õ–Ø –õ–ï–ù–ò–í–û–ô –ó–ê–ì–†–£–ó–ö–ò ============
    class LazyPDFReader:
        """–õ–µ–Ω–∏–≤—ã–π –∑–∞–≥—Ä—É–∑—á–∏–∫ PDF - –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏"""
        def __init__(self, file_path: str):
            self.file_path = file_path
            self._pdf = None
            self._total_pages = None
        
        def __enter__(self):
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            if self._pdf:
                self._pdf.close()
        
        @property
        def total_pages(self) -> int:
            if self._total_pages is None:
                import pdfplumber
                with pdfplumber.open(self.file_path) as temp_pdf:
                    self._total_pages = len(temp_pdf.pages)
            return self._total_pages
        
        def get_page(self, page_num: int):
            """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ –Ω–æ–º–µ—Ä—É (–Ω–∞—á–∏–Ω–∞—è —Å 1)"""
            if page_num < 1 or page_num > self.total_pages:
                raise IndexError(f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num} –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ 1-{self.total_pages}")
            
            if self._pdf is None:
                import pdfplumber
                self._pdf = pdfplumber.open(self.file_path)
            
            return self._pdf.pages[page_num - 1]
        
        def close(self):
            """–ó–∞–∫—Ä—ã—Ç—å PDF —Ñ–∞–π–ª"""
            if self._pdf:
                self._pdf.close()
                self._pdf = None

    # ============ –ù–û–í–´–ô –ú–ï–¢–û–î: –ü–ê–†–°–ò–ù–ì –° –õ–ï–ù–ò–í–û–ô –ó–ê–ì–†–£–ó–ö–û–ô ============
    def parse_with_lazy_loading(self, file_path: str, 
                                start_page: int = 1, 
                                end_page: Optional[int] = None,
                                max_pages: Optional[int] = None) -> pd.DataFrame:
        """
        –ü–∞—Ä—Å–∏–Ω–≥ —Å –ª–µ–Ω–∏–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü - —ç–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å
        
        :param file_path: –ü—É—Ç—å –∫ PDF —Ñ–∞–π–ª—É
        :param start_page: –ù–æ–º–µ—Ä –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–Ω–∞—á–∏–Ω–∞—è —Å 1)
        :param end_page: –ù–æ–º–µ—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã (None = –¥–æ –∫–æ–Ω—Ü–∞)
        :param max_pages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü
        :return: DataFrame —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        """
        try:
            import pdfplumber
        except ImportError:
            raise RuntimeError("‚ùå –ë–ò–ë–õ–ò–û–¢–ï–ö–ê PDFPLUMBER –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ê! –í—ã–ø–æ–ª–Ω–∏—Ç–µ: pip install pdfplumber")
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"‚ùå –§–ê–ô–õ –ù–ï –ù–ê–ô–î–ï–ù: {file_path}")
        
        self._log("üöÄ" * 50)
        self._log(f"üöÄ –ó–ê–ü–£–°–ö –ü–ê–†–°–ò–ù–ì–ê –° –õ–ï–ù–ò–í–û–ô –ó–ê–ì–†–£–ó–ö–û–ô: {os.path.basename(file_path)}")
        self._log(f"üìÅ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å: {file_path}")
        
        try:
            all_tables = []
            total_pages_processed = 0
            total_pages_skipped = 0
            
            with self.LazyPDFReader(file_path) as lazy_pdf:
                total_pages = lazy_pdf.total_pages
                self._log(f"üìÑ –û–ë–ù–ê–†–£–ñ–ï–ù–û –°–¢–†–ê–ù–ò–¶ –í PDF: {total_pages}")
                
                # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü
                if start_page < 1:
                    start_page = 1
                
                if end_page is None:
                    end_page = total_pages
                elif end_page > total_pages:
                    end_page = total_pages
                
                # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ max_pages
                pages_in_range = end_page - start_page + 1
                if max_pages and max_pages > 0 and pages_in_range > max_pages:
                    end_page = start_page + max_pages - 1
                
                self._log(f"üìÑ –î–ò–ê–ü–ê–ó–û–ù –û–ë–†–ê–ë–û–¢–ö–ò: —Å—Ç—Ä–∞–Ω–∏—Ü—ã {start_page}-{end_page}")
                
                for page_num in range(start_page, end_page + 1):
                    # üî• –í–´–ó–´–í–ê–ï–ú –û–ë–†–ê–¢–ù–´–ô –í–´–ó–û–í –ü–†–û–ì–†–ï–°–°–ê (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
                    if self.progress_callback:
                        self.progress_callback(page_num - start_page + 1, end_page - start_page + 1)
                    
                    # üî• –õ–ï–ù–ò–í–ê–Ø –ó–ê–ì–†–£–ó–ö–ê: —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∑–¥–µ—Å—å
                    page = lazy_pdf.get_page(page_num)
                    
                    # üî• –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê: –°–¢–û–ò–¢ –õ–ò –û–ë–†–ê–ë–ê–¢–´–í–ê–¢–¨ –≠–¢–£ –°–¢–†–ê–ù–ò–¶–£?
                    if not self._should_process_page(page, page_num):
                        total_pages_skipped += 1
                        # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
                        del page
                        continue
                    
                    self._log(f"\nüìñ {'='*60}")
                    self._log(f"üìñ –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–†–ê–ù–ò–¶–´ {page_num}/{end_page} (–ª–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞)")
                    self._log(f"üìñ {'='*60}")
                    
                    page_tables = self._extract_tables_universal(page, page_num)
                    if page_tables:
                        all_tables.extend(page_tables)
                        total_pages_processed += 1
                    
                    # –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü—ã
                    if page_tables:
                        self._extract_and_analyze_text(page, page_num)
                    
                    # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                    del page
                    import gc
                    gc.collect()
            
            # –°–≤–æ–¥–∫–∞ –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ
            self._log(f"\nüìä {'='*60}")
            self._log(f"üìä –°–í–û–î–ö–ê –ü–û –ü–ê–†–°–ò–ù–ì–£ (–ª–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞):")
            self._log(f"üìä –í—Å–µ–≥–æ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ PDF: {total_pages}")
            self._log(f"üìä –î–∏–∞–ø–∞–∑–æ–Ω –æ–±—Ä–∞–±–æ—Ç–∫–∏: {start_page}-{end_page}")
            self._log(f"üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_processed}")
            self._log(f"üìä –ü—Ä–æ–ø—É—â–µ–Ω–æ —Å—Ç—Ä–∞–Ω–∏—Ü: {total_pages_skipped}")
            self._log(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(all_tables)}")
            self._log(f"üìä {'='*60}")
            
            if all_tables:
                # –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –ª—É—á—à–∏–µ —Ç–∞–±–ª–∏—Ü—ã (–±–µ–∑ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü)
                best_tables = []
                pages_processed = set()
                for table in all_tables:
                    page = table['_source_page'].iloc[0] if '_source_page' in table.columns else 0
                    if page not in pages_processed:
                        best_tables.append(table)
                        pages_processed.add(page)
                
                self._log(f"üìä –í—ã–±—Ä–∞–Ω–æ {len(best_tables)} –ª—É—á—à–∏—Ö —Ç–∞–±–ª–∏—Ü –∏–∑ {len(all_tables)}")
                result_df = self._merge_all_tables(best_tables)
            else:
                result_df = pd.DataFrame()
            
            result_df = self._replace_na_values(result_df)
            self._analyze_final_result(result_df, file_path)
            
            if not result_df.empty:
                self._log(f"‚úÖ –£–°–ü–ï–•! –°–û–ó–î–ê–ù DATAFRAME: {result_df.shape}")
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–∞–¥–∏–∞—Ç–æ—Ä—ã –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                radiators = self.extract_radiators_from_dataframe(result_df)
                self._log(f"‚úÖ –ò–∑–≤–ª–µ—á–µ–Ω–æ {len(radiators)} –ø–æ–∑–∏—Ü–∏–π —Ä–∞–¥–∏–∞—Ç–æ—Ä–æ–≤")
            else:
                self._log("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –í PDF –ù–ï –ù–ê–ô–î–ï–ù–û –¢–ê–ë–õ–ò–ß–ù–´–• –î–ê–ù–ù–´–•")
            
            return result_df
            
        except Exception as e:
            error_msg = f"‚ùå –û–®–ò–ë–ö–ê –ü–ê–†–°–ò–ù–ì–ê –° –õ–ï–ù–ò–í–û–ô –ó–ê–ì–†–£–ó–ö–û–ô {file_path}:\n{str(e)}\n{traceback.format_exc()}"
            self._log(error_msg, "ERROR")
            raise RuntimeError(error_msg)

# ============ –¢–ï–°–¢–û–í–´–ô –ë–õ–û–ö ============
if __name__ == "__main__":
    # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞
    parser = PDFParser()
    
    # –¢–µ—Å—Ç–æ–≤—ã–π PDF —Ñ–∞–π–ª
    test_pdf = "03_2023-72.206, 72.208-–û–í_—Å–µ–∫—Ü–∏—è 1.pdf"
    
    if os.path.exists(test_pdf):
        print("\nüß™ –¢–ï–°–¢–ò–†–£–ï–ú –ù–û–í–´–ô –§–£–ù–ö–¶–ò–û–ù–ê–õ –° –î–ò–ê–õ–û–ì–û–í–´–ú–ò –û–ö–ù–ê–ú–ò...")
        
        print("\n1. üìÑ –¢–µ—Å—Ç–∏—Ä—É–µ–º —É–º–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ (—Å –¥–∏–∞–ª–æ–≥–æ–º):")
        print("   üí° –û—Ç–∫—Ä–æ–µ—Ç—Å—è –æ–∫–Ω–æ –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü...")
        try:
            # –î–ª—è —Ç–µ—Å—Ç–∞ –æ—Ç–∫–ª—é—á–∞–µ–º –¥–∏–∞–ª–æ–≥, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–∞—Ç—å
            df1 = parser.smart_parse(test_pdf, show_dialog=False)
            print(f"   –†–µ–∑—É–ª—å—Ç–∞—Ç (–±–µ–∑ –¥–∏–∞–ª–æ–≥–∞): {df1.shape if not df1.empty else '–ø—É—Å—Ç–æ'}")
        except Exception as e:
            print(f"   –û—à–∏–±–∫–∞: {e}")
        
        print("\n2. üìÑ –¢–µ—Å—Ç–∏—Ä—É–µ–º –±—ã—Å—Ç—Ä—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏:")
        try:
            df2 = parser.quick_parse_only_tables(test_pdf)
            print(f"   –†–µ–∑—É–ª—å—Ç–∞—Ç: {df2.shape if not df2.empty else '–ø—É—Å—Ç–æ'}")
        except Exception as e:
            print(f"   –û—à–∏–±–∫–∞: {e}")
        
        print("\n3. üìÑ –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü:")
        try:
            df3 = parser.parse_to_dataframe(test_pdf, start_page=1, end_page=5, max_pages=3)
            print(f"   –†–µ–∑—É–ª—å—Ç–∞—Ç: {df3.shape if not df3.empty else '–ø—É—Å—Ç–æ'}")
        except Exception as e:
            print(f"   –û—à–∏–±–∫–∞: {e}")
        
        print("\n4. üìÑ –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ —Å –¥–∏–∞–ª–æ–≥–æ–º (–∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –∞–≤—Ç–æ—Ç–µ—Å—Ç–æ–≤):")
        print("   # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞:")
        print("   # df4 = parser.parse_with_dialog(test_pdf)")
        print("   # df4 = parser.smart_parse(test_pdf, show_dialog=True)")
        
        print("\nüìä –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Æ:")
        print("   1. –î–ª—è GUI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ: parser.parse_with_dialog(file_path)")
        print("   2. –î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏: parser.quick_parse_only_tables(file_path)")
        print("   3. –î–ª—è –ø–∞–∫–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏: parser.parse_to_dataframe(file_path, start_page=X, end_page=Y)")
        print("   4. –î–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏: parser.parse_with_lazy_loading(file_path)")
        
    else:
        print(f"‚ùå –¢–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {test_pdf}")
        print("\nüí° –ü–†–ò–ú–ï–†–´ –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø –ù–û–í–û–ì–û –§–£–ù–ö–¶–ò–û–ù–ê–õ–ê:")
        print("\n–° –¥–∏–∞–ª–æ–≥–æ–≤—ã–º –æ–∫–Ω–æ–º:")
        print("   df = parser.parse_with_dialog('file.pdf')")
        print("   df = parser.smart_parse('file.pdf', show_dialog=True)")
        
        print("\n–ë–µ–∑ –¥–∏–∞–ª–æ–≥–∞ (–ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ):")
        print("   df = parser.parse_to_dataframe('file.pdf', start_page=5, end_page=15)")
        print("   df = parser.parse_to_dataframe('file.pdf', max_pages=50)")
        print("   df = parser.quick_parse_only_tables('file.pdf')")
        print("   df = parser.parse_with_lazy_loading('file.pdf', start_page=1, end_page=100)")